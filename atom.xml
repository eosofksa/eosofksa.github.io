<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EOS 블로그</title>
  
  <subtitle>Computer Club of KSA</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://eosofksa.github.io/"/>
  <updated>2018-05-12T14:25:48.124Z</updated>
  <id>http://eosofksa.github.io/</id>
  
  <author>
    <name>EOS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018 SAF Event!</title>
    <link href="http://eosofksa.github.io/2018/05/11/2018-SAF-Event/"/>
    <id>http://eosofksa.github.io/2018/05/11/2018-SAF-Event/</id>
    <published>2018-05-11T05:31:35.000Z</published>
    <updated>2018-05-12T14:25:48.124Z</updated>
    
    <content type="html"><![CDATA[<p>2018 SAF 이벤트!<br><a id="more"></a></p><ol><li>게임 잡학 퀴즈!<br>EOS 16의 감미로운 음악가 요한이가 낸 <a href="https://eosofksa.github.io/2018/05/09/Game-quizzes/">게임 잡학 퀴즈</a>를 풀어서 EOS 16에게 답을 보내면 추첨을 통해서 경품을 드립니다!</li></ol><p><img src="/images/2018-SAF_Event-HootYohan.jpg" alt="훗, 한 번 풀어보시지!"></p><ol start="2"><li>블로그 런칭 기념 이벤트!<br>블로그에 올라온 글 중 가장 마음에 드는 글을 골라 댓글에 감상평을 적어주세요! 써비 사비 다 털어서 상품을 드립니다!<br>SAF를 위해 열심히 글을 쓴 EOS 16들을 위해 한 번씩 읽어주세요ㅎㅎ<br>+) 댓글 달 때 꼭 학번 이름 써주셔야 하고, 혹시 페이스북/트위터/구글 계정이 없다거나 해서 댓글을 달 수 없는 경우 카톡으로 보내주셔도 됩니다!</li></ol><hr><p><strong style="font-size:1.2em;">EOS 16</strong><br><strong class="nametag_bold">16-001 강래현</strong> | <strong class="nametag_bold">16-010 김기환</strong> | <strong class="nametag_bold">16-045 박홍근</strong> | <strong class="nametag_bold">16-057 양경민</strong> | <strong class="nametag_bold">16-065 윤요한</strong> | <strong class="nametag_bold">16-077 이원준</strong> | <strong class="nametag_bold">16-120 홍성범</strong><br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:eosofksa@gmail.com" target="_blank" rel="noopener">eosofksa@gmail.com</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 SAF 이벤트!&lt;br&gt;
    
    </summary>
    
      <category term="-Notice-" scheme="http://eosofksa.github.io/categories/Notice/"/>
    
    
  </entry>
  
  <entry>
    <title>대부분은 버그입니다</title>
    <link href="http://eosofksa.github.io/2018/05/10/%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80-%EB%B2%84%EA%B7%B8%EC%9E%85%EB%8B%88%EB%8B%A4/"/>
    <id>http://eosofksa.github.io/2018/05/10/대부분은-버그입니다/</id>
    <published>2018-05-10T07:21:00.000Z</published>
    <updated>2018-05-10T15:02:47.604Z</updated>
    
    <content type="html"><![CDATA[<p>히트를 친 Top 5 게임 속 버그들<br><a id="more"></a></p><ol start="5"><li>로켓 점프 <br><br><img src="/images/대부분은-버그입니다-rocket.png" alt=""><br>로켓 점프는 오버워치, 팀 포트리스 2, 포트나이트 등 fps/tps 게임을 해본 사람이라면 친숙한 개념일 것이다. 점프를 하는 동시에 로켓을 바닥에 쏘면 평소의 1.5~2배 가량의 높이에 다다를 수 있는, 게임이니까 가능한 테크닉이다. 이러한 기술은 1996년 Quake에서 의도되지 않게 게임에 추가된 이래 큰 인기를 끌어, 이후 거의 모든 fps 게임들이 게임 물리엔진에 도용하는 기술이 되버렸다.</li></ol><ol start="4"><li>핵쟁이 간디 <br><br><img src="/images/대부분은-버그입니다-Ghandi.png" alt=""><br>문명 시리즈를 해본 사람이라면 우리가 흔히 아는 역사적 인물인 간디라는 사람이 얼마나 무서운지 알 것이다. 툭하면 핵을 날리는 간디의 테러에 수많은 플레이어들이 고뇌하였다. 이러한 문명 시리즈의 전통인 간디의 횡포는 사실 버그로부터 비롯되었었다. 원래 간디의 공격성 수치는 1로 게임에서 가장 낮은 스탯을 갖고 있다. 하지만 이때 인도에 민주주의를 도입 시, 게임원칙에 따라 공격성이 1이 줄어들게 된다. 이에 따라 간디의 공격성 수치는 오버플로우가 일어나 공격성 최댓값인 255로 설정되게 된다. 이 때문에 간디는 문명 시리즈의 타노스로써 이름을 남기게 되었고, 제작자들은 후속작에서도 이 전통을 남기기로 결심하여, 우리가 현재 아는 핵을 사랑하는 간디가 탄생하게 되었다.</li></ol><ol start="3"><li>GTA의 미친 경찰들 <br><br>1995년, 스튜디오 DMA 디자인은 “Race n Chase’라는 게임을 제작 중이었다. 이 게임은 경찰 혹은 범인 중 한 편을 골라 오픈 월드에서 미션을 수행하는 액션게임으로, 운전에 큰 중점을 둔 게임이었다. 여러 가지 테스트 코드를 넣으면서 플레이테스트를 하는 도중, 제작자들은 경찰 AI가 미쳐 날뛰어 플레이어를 보자마자 민간인들은 개의치 않고 쫓아와 주인공을 차로 치는 등 의도치 않은 결과를 내버렸었다. 우연케도 만들어낸 미친 경찰 AI가 현재까지 만들고 있었던 게임보다 더 재미있다고 판단된 이들은 게임의 방향을 완전히 바꿔, 오픈월드에서 추격하는 경찰을 피하며, 범죄자로 노닥거리는 게임을 만들었다. 이것이 곧 GTA가 탄생하게 된 이유였다고 한다…</li></ol><ol start="2"><li>스트리트 파이터 2의 캔슬기/콤보 기능 <br><br><img src="/images/대부분은-버그입니다-fighter.png" alt=""><br>격투 게임이라 하면 흔히 멋진 콤보를 통해 상대방을 꼼짝 못하게 제압하는 모습을 상상할 수 있을 것이다. 근데 이 ‘콤보’라는 개념은 격투라는 장르가 생겼을 때부터 존재해온 개념은 아니다. 초기 격투게임들은 대부분 방어, 점프, 공격 등의 기술을 마치 가위바위보 형식으로 상대방이 방어를 하지 않는 타이밍을 노리는 것만이 전부인 아주 단순한 형태였다. 이는 스트리트 파이트 2의 출시로 확 달라지게 되었다. 스트리트 파이트 2는 코드 상 오류로 인해 기술을 사용한 후 공격 애니메이션을 중간에 캔슬하여 다른 기술을 이어서 쓰는 것이 가능했다. 즉, 공격을 연달아 사용하여 맞히는 ‘콤보’가 가능했던 것이다. 후에 ‘캔슬기’라고 불러지게 된 이 개념은 지금까지도 스트리트 파이터 2가 격투 장르의 가장 중요한 게임이 되는 데에 기여하였다.</li></ol><ol><li>Space Invaders의 난이도 곡선 <br><br><img src="/images/대부분은-버그입니다-space.png" alt=""><br>거의 모든 게임에는 레벨, 혹은 어떤 형태의 난이도 곡선이 존재한다. 처음에는 쉬운 난이도와 튜토리얼로 플레이어를 가르치고, 점점 어려워지는 난이도를 통해 게임에 대한 플레이어의 흥미를 유지시킨다. 아주 간단하고 널리 알려진 게임의 일반적인 특성이다. 그렇지만 이 또한 신기하게도 원래는 버그, 혹은 시스템 상 한계 때문에 생겨난 개념이다. 스페이스 인베이더를 처음 시작할 때에는 적(외계인) 오브젝트의 수가 너무 많아 게임 시스템의 속도 저하로 자연스럽게 적들의 속도가 느리다. 적들을 웬만큼 쓰러트린 이후에는 적들의 수가 적어졌기에 속도가 다시 정상으로 돌아와 점차 속도가 빨라지는 모습, 즉 난이도가 점점 증가하는 모습을 보인다. 이 난이도가 점차 증가하는 모습은 게임의 중독성, 재미에 큰 효과를 주어, 그 이후 나온 거의 모든 게임에 지금까지 영향을 주고 있다.</li></ol><hr><p><strong style="font-size:1.2em;">16-065 윤요한</strong><br><strong class="nametag_bold">(Yo-Han Yoon | Johnny Youngster)</strong><br>– Youtuber / Music Producer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:yohanme@naver.com" target="_blank" rel="noopener">yohanme@naver.com</a></i>, <i class="icon fa fa-youtube-play" style="font-size:1em;"> <a href="https://www.youtube.com/channel/UCQ7yoYi-qvppChAIlbLalAQ" target="_blank" rel="noopener">Johnny Youngster</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;히트를 친 Top 5 게임 속 버그들&lt;br&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-065 Yo-Han Yoon" scheme="http://eosofksa.github.io/categories/KSA-16/16-065-Yo-Han-Yoon/"/>
    
    
      <category term="Game" scheme="http://eosofksa.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>키보드는 왜 이렇게 생겼을까 1</title>
    <link href="http://eosofksa.github.io/2018/05/10/%ED%82%A4%EB%B3%B4%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%83%9D%EA%B2%BC%EC%9D%84%EA%B9%8C-1/"/>
    <id>http://eosofksa.github.io/2018/05/10/키보드는-왜-이렇게-생겼을까-1/</id>
    <published>2018-05-10T05:15:00.000Z</published>
    <updated>2018-05-10T14:54:37.563Z</updated>
    
    <content type="html"><![CDATA[<p>키보드는 왜 이렇게 생겼을까 1 - Scroll Lock<br><a id="more"></a></p><p>키보드를 오랫동안 쓰다 보면 많이 쓰는 키들이 기름때로 더러워지고 각인이 벗겨지는 것을 볼 수 있다. 사무실 키보드는 손가락이 항상 닿아있는 ㅁ,ㄴ,ㅇ,ㄹ 키가 기름때로 번들거리고, PC방 키보드는 W,A,S,D키의 각인이 벗겨져 있는 것을 볼 수 있다. 하지만 scroll lock키가 더러운 키보드를 보기는 힘들다. 최근의 노트북 키보드에서는 scroll lock키가 없을 정도로 쓰지 않는 경우가 많다. Scroll lock키는 왜 104키 배열에 포함되어 있을까?</p><p><img src="/images/키보드는-왜-이렇게-생겼을까-1-XPS13Keyboard.png" alt="xps13 키보드. Scroll lock이 아예 달려있지 않다."></p><p>사실 scroll lock의 쓰임을 분명히 기억하고 있는 사람도 많다. 지금 우리는 컴퓨터로 문서를 작성할 때 마우스나 트랙패드를 사용하여 커서를 옮기고, 스크롤 휠 또는 트랙패드를 움직여 문서 전체를 움직인다. 하지만 스크롤 휠 이 달린 마우스가 보편화되기 전에는 방향키로 문서를 움직여야 했는데, 대부분의 워드 프로세서는 scroll lock을 누르면 방향키를 스크롤처럼 사용할 수 있는 기능을 갖고 있었다.</p><p><img src="/images/키보드는-왜-이렇게-생겼을까-1-MSWord5_1.png" alt="Microsoft word 5.1, 출처: http://enacademic.com/dic.nsf/enwiki/12292"></p><p>하지만 지금 당장 마이크로소프트 워드를 열면 scroll lock을 눌러도 아무것도 일어나자 않는다. 대부분의 마우스에는 스크롤 휠 이 달려있고, 노트북 컴퓨터의 트랙 패드도 스크롤 기능이 있기 때문에 더 이상 scroll lock 을 사용할 이유가 없다.<br>그렇다고 scroll lock의 기능이 완전히 없는 것은 아니다. 아직도 대부분의 키보드에는 scroll lock키가 달려 있으며, 유용하게 사용할 여지가 있다.</p><ol><li>마이크로소프트 엑셀<br>엑셀은 scroll lock키의 본래 용도가 남아있는 몇 안되는 프로그램 중 하나이다. Scroll lock을 누르면 방향키로 상하좌우의 셀을 선택하는 대신 스프레드시트 전체를 스크롤 할 수 있다. 오래된 노트북의 스크롤이 불편하다면 오히려 이 방법이 더 편할 수도 있다.</li></ol><ol start="2"><li>KVM 스위치 기능<br>여러 대의 컴퓨터를 하나의 키보드로 제어할 수 있도록 도와주는 키보드/비디오/마우스 스위치에서는 scroll lock 두번+숫자 키로 입력을 변경할 수 있는 경우가 많다.</li></ol><ol start="3"><li>여분의 키 <br><br><img src="/images/키보드는-왜-이렇게-생겼을까-1-Sharpkeys.png" alt="https://github.com/randyrants/sharpkeys/releases – sharpkeys 키맵핑 프로그램"><br>사실 쓸만한 마우스와 트랙 패드의 스크롤 기능을 이용하는 것이 scroll lock 보다 엑셀 작업에 도움이 되며, KVM 스위치는 서버 관리를 하지 않는 이상 사용할 일이 없다. Scroll lock키는 스크롤 휠의 등장 이후로 사실상 기능을 잃었지만, 새로운 기능을 할당할 수 있는 빈 공간이 생겼다고 생각해볼 수도 있다. 키 맵핑 프로그램 등을 사용하여 새로운 기능을 부여해 주자. 3개 이상의 언어를 사용한다면 다른 레이아웃으로 빠르게 변경할 수 있는 키로 사용할 수도 있고, 특정 프로그램에 적합한 키 배열로 전환하는 등 한 개의 빈칸으로 할 수 있는 일이 많다.</li></ol><hr><p><strong style="font-size:1.2em;">16-120 홍성범</strong><br><strong class="nametag_bold">(Sung-Beum Hong | 데카코어)</strong><br>– 디스플레이, 무선기술, 3D프린팅, 게임개발, 종합 하드웨어 매니아 / Unity Developer and Engineer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:beum3169develop@gmail.com" target="_blank" rel="noopener">beum3169develop@gmail.com</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;키보드는 왜 이렇게 생겼을까 1 - Scroll Lock&lt;br&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-120 Sung-Beum Hong" scheme="http://eosofksa.github.io/categories/KSA-16/16-120-Sung-Beum-Hong/"/>
    
    
      <category term="Hardware" scheme="http://eosofksa.github.io/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>증강현실 기기의 현 주소</title>
    <link href="http://eosofksa.github.io/2018/05/10/%EC%A6%9D%EA%B0%95%ED%98%84%EC%8B%A4-%EA%B8%B0%EA%B8%B0%EC%9D%98-%ED%98%84-%EC%A3%BC%EC%86%8C/"/>
    <id>http://eosofksa.github.io/2018/05/10/증강현실-기기의-현-주소/</id>
    <published>2018-05-10T05:11:00.000Z</published>
    <updated>2018-05-10T14:54:48.451Z</updated>
    
    <content type="html"><![CDATA[<p>그래서 홀로렌즈는 언제 출시되는 겁니까?<br><a id="more"></a></p><p><img src="/images/증강현실-기기의-현-주소-IronMan.png" alt="영화 ‘아이언맨’에 등장하는 증강현실 기술"></p><p>증강현실은 우리가 보는 시야 위에 여러 가지 정보를 표시해 주는 디스플레이 기술이라고 할 수 있다. 이러한 기술은 각종 SF영화에서 다양한 형태로 항상 등장하며, 구글 글라스와 마이크로소프트 홀로렌즈 등의 증강현실 기기가 주목 받기도 하였다. 하지만 구글 글라스와 마이크로소프트 홀로렌즈 모두 제대로 출시 되지도 않은 상태로 프로젝트가 끝나 버리고 말았다. 증강현실 장치에 사용된 기술에 대해 알아보면서 왜 AR이 VR만큼 대중화되지 못했는지 알아보자.</p><p><img src="/images/증강현실-기기의-현-주소-GoogleGlass.png" alt="구글 글라스. 640*360 해상도의 이미지를 표시한다."></p><p>먼저 증강현실 기기라는 새로운 이름이 붙었을 뿐 결국 픽셀로 이루어진 디스플레이 기술이다. 하지만 디스플레이를 단순히 컴퓨터의 출력 장치라고 생각해서는 안 된다. 소비자용 전자기기에서 가장 중요한 부품은 디스플레이라고 해도 과언이 아니다. 애플이 강조하는 직관적인 동작 방식의 바탕은 결국 디스플레이이다. 아무리 좋은 프로세서와 빠른 메모리 칩을 달았다고 해도 낮은 해상도의 어두운 디스플레이가 달린 제품은 팔리지 않는다. 디스플레이는 사용자와 컴퓨터 사이를 가장 빠르게 이어주는 도구이며, UI라는 것도 디스플레이가 있기 때문에 존재할 수 있다.</p><p>그렇다면 현재 증강현실 디스플레이에 이용되고 있는 기술 두 가지에 대해 알아보자.</p><h2 id="DLP-Digital-Light-Projection"><a href="#DLP-Digital-Light-Projection" class="headerlink" title="DLP(Digital Light Projection)"></a>DLP(Digital Light Projection)</h2><p><img src="/images/증강현실-기기의-현-주소-VuzixAndPicoProjection.png" alt="VUZIX사의 인공지능 탑재 증강현실 안경. 오른쪽은 갤럭시빔2 스마트폰에 쓰인 피코 프로젝션 모듈."></p><p>DLP는 초소형 프로젝터에 주로 이용되고 있다. 한국에는 출시되지 않았던 갤럭시 빔에 적용된 프로젝터 기술이며, CES 2018에서 주목받은 VUZIX사의 증강현실 안경이 이 방식을 사용하고 있다.</p><p><img src="/images/증강현실-기기의-현-주소-TI_DMD.png" alt="TI DMD 픽셀의 구조"></p><p>초소형 DLP 기술의 핵심은 DMD(Digital Micromirror Device)에 있다. DMD는 움직일 수 있는 초소형 거울로, 픽셀이 켜져 있을 때는 빛을 프로젝션 렌즈로 반사 시키고, 픽셀이 꺼져 있을 때는 다른 곳으로 빛을 보내 픽셀이 꺼진다. PWM을 통해 그레이스케일을 표현할 수도 있다. 이 기술을 통해 기존 DLP 프로젝터의 움직이는 부품들을 많이 줄이고 소형화, 경량화 할 수 있다. 또한 거울을 움직이는 시간이 10밀리초 이내이기 때문에 100밀리초 내외의 응답시간을 가지는 LCD에 비해 반응 속도가 빠르다는 장점도 있다.</p><h2 id="FSC-LCoS-liquid-crystal-on-silicon"><a href="#FSC-LCoS-liquid-crystal-on-silicon" class="headerlink" title="FSC LCoS (liquid crystal on silicon)"></a>FSC LCoS (liquid crystal on silicon)</h2><p><img src="/images/증강현실-기기의-현-주소-GoogleGlassSightPath.png" alt="구글 글라스의 광경로. 출처: Quora/Sid Harza"></p><p>구글 글라스는 더 작고 가벼운 제품을 만들기 위해 LCoS 디스플레이를 사용한다. 흔히 사용되는 LCD 디스플레이는 유리 위에 액정이 있고, 편광된 빛이 유리와 픽셀을 통과한다. LCoS 디스플레이의 경우 실리콘 기판 위에 액정이 있기 때문에 뒤에서 빛을 통과시킬 수 없는 대신 빛을 반사시킨다. LCoS는 LCD에 비해 작게 만들기에 용이하고 전력 사용량이 적다는 장점을 가진다. 빛을 반사시켜 픽셀을 표현한다는 점에서 LCoS는 LCD보다 DMD와 비슷한 구조라고 할 수 있으나, LCoS의 경우 들어오고 나가는 빛의 경로가 똑같다는 차이점이 존재한다.<br>DMD와 LCoS 모두 편광 광원을 사용하며, R,G,B 세 개의 광원으로 Field-sequential color system을 통해 색을 표현한다. 피코 프로젝션 장치의 광원도 흥미로운 주제이지만, 나중의 글에서 다루도록 한다.</p><h2 id="기술은-있는데-왜-제품은-없는-거죠"><a href="#기술은-있는데-왜-제품은-없는-거죠" class="headerlink" title="기술은 있는데 왜 제품은 없는 거죠?"></a>기술은 있는데 왜 제품은 없는 거죠?</h2><p>현재 초소형 OLED/DLP/LCoS 디스플레이 개발도 활발하게 진행되고 있으며 다양한 스타트업들이 다양한 기술을 바탕으로 증강현실에 접근하고 있지만 구글 글라스가 공개된 지 5년이 지났음에도 소비자 입장에서는 구매할 수 없는 기기라는 사실은 똑같다. 기술이 있음에도 제품이 없는 이유는 무엇일까?<br>먼저 증강현실은 가격이 비싸기 실패한 것은 아니다. 구글 글라스는 100만원대에 판매될 예정이었는데, VR기기의 발달과정을 살펴보면 VR을 즐기기 위해서 60~70만원대의 기기와 150만원 이상의 고성능 PC가 필요함에도 불구하고 크게 성장한 것을 보면 새로운 기술을 먼저 접해보고 싶은 사람들에게 충분히 어필할 수만 있다면 전혀 문제될 것이 없는 가격 이였다.</p><p><img src="/images/증강현실-기기의-현-주소-OculusRiftVR.png" alt="oculus rift VR. 600$라는 가격에도 불구하고 2017년에 20만대 이상 판매되었다."></p><p>구글 글라스의 실패 원인은 실패한 마케팅과 제품에 대한 인식 부족 이였다. 구글 글라스는 많은 개발자들에게 배포되었고 상당한 양의 생산 및 판매도 이루어졌다. 하지만 구글이 프로젝트 종료를 선언하기 전까지 한번도 정식 출시일은 나오지 않았다. 또한 끝없는 컨텐츠와 게임을 내세운 VR과 달리 정작 구글 글라스의 기능은 시계와 도착한 메시지를 보여주는 정도밖에 없었다. 멋있다는 이유 외에는 쓸모가 별로 없다는 점은 스마트 워치의 실패 사유와 비슷하다고 볼 수 있다.<br>구글 글라스 이후 현재 AR의 성장을 막고 있는 가장 큰 벽은 이전에 없었던 기술이 새로 개발되어야 하며, 소비자들이 제품을 구매할 이유를 새로 제시해야 된다는 점이다. 비슷한 영역이라고 할 수 있는 VR기술은 현실과 비슷한 가상 공간을 만드는 게임 엔진과 3D 그래픽 처리 기술, 그리고 고성능 PC라는 이미 개발되어 있는 기술의 도움을 크게 받았기 때문에 소비자들에게 새로운 경험을 제공할 수 있었고, 새로운 게임과 컨텐츠를 즐기기 위해 비싼 기기와 소프트웨어를 구매하기를 원하는 사람들도 많다.</p><p>이와 반대로 AR기술에 필요한 가벼운 저전력 CPU는 사용자의 입력과 부드럽게 상호작용하는 UI를 구현하는 것조차 버거운 상황이다. 마이크로소프트사는 홀로렌즈에 사용되는 인텔 아톰 칩의 성능 문제를 해결하기 위해 HPU라는 자체개발 칩까지 동원했지만 동작이 부드럽지 않다는 평가가 많다. 또한 지금의 AR기기들은 (구글 글라스가 실패한) 일반 소비자 대상이 아닌 기업과 산업현장을 타겟으로 한 제품들이 개발되고 있는데, 이런 분야에서 완전히 새로운 제품의 필요성을 입증하는 것 또한 쉬운 일이 아니다.</p><p>눈앞에 투명한 디스플레이를 달고 다닌다는 AR기술은 분명히 매력적이다. 하지만 이것이 대중화 되려면 가격이 파격적으로 내려오거나 단순한 정보 전달 이상의 새로운 경험을 제공해야 할 것이다.</p><hr><p><strong style="font-size:1.2em;">16-120 홍성범</strong><br><strong class="nametag_bold">(Sung-Beum Hong | 데카코어)</strong><br>– 디스플레이, 무선기술, 3D프린팅, 게임개발, 종합 하드웨어 매니아 / Unity Developer and Engineer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:beum3169develop@gmail.com" target="_blank" rel="noopener">beum3169develop@gmail.com</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;그래서 홀로렌즈는 언제 출시되는 겁니까?&lt;br&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-120 Sung-Beum Hong" scheme="http://eosofksa.github.io/categories/KSA-16/16-120-Sung-Beum-Hong/"/>
    
    
      <category term="AR (Augmented Reality)" scheme="http://eosofksa.github.io/tags/AR-Augmented-Reality/"/>
    
  </entry>
  
  <entry>
    <title>증명 없는 증명</title>
    <link href="http://eosofksa.github.io/2018/05/10/Zero-Knowledge-Proof/"/>
    <id>http://eosofksa.github.io/2018/05/10/Zero-Knowledge-Proof/</id>
    <published>2018-05-10T03:02:03.000Z</published>
    <updated>2018-05-11T05:31:17.189Z</updated>
    
    <content type="html"><![CDATA[<p>Zero Knowledge Proof / 영지식증명</p><a id="more"></a><p>‘미션 임파서블’ 시리즈를 아는가? ‘미션 임파서블’은 톰 크루즈가 주연을 맡고 있는 첩보 영화로 각 영화마다 한시도 눈을 땔 수 없는 화려한 액션과 우리의 상상력을 자극하는 첨단 기술들을 보여주며 엄청난 인기를 얻고 있다. 이러한 ‘미션 임파서블’ 시리즈 말고도 ‘007’ 시리즈, ‘킹스맨’과 같은 수많은 첩보 영화가 나오고 있으며 이 영화들도 많은 인기를 끌었다. 그렇다면 앞서 말한 영화들의 스파이들의 공통점은 무엇일까? 다른 말로 스파이에게 중요한 것은 무엇일까? 이런 질문을 받으면 ‘적지에서 임무를 수행하고 빠져 나올 수 있을 만큼 전투를 잘하며, 온갖 첨단 장비를 지니고 있어야 한다.’ 라고 생각할 것이다. 하지만 현실에서는 영화와는 달리 이런 전투 능력이나 기술력보다는 들키지 않고 임무를 수행하는 것이 최우선이 되어야만 할 것이다. 그렇다면 우선 스파이와 스파이 사이의 신원 확인이나 스파이와 본국 사이의 신원 확인에서 자신의 정체를 들킬 위험을 최소화 시켜야 할 것이다. 이러한 위험을 최소화 시키기 위해서는 신원 확인 과정에서 자신의 정보가 최소한으로 드러나는 것이 중요하다. 하지만 상식적으로 생각해보면 자신의 정보를 드러내지 않으면서 자신의 신원을 증명한다는 것은 불가능해 보인다. 그럼 지금부터 불가능처럼 보이는 일을 현실로 만들어주는 암호 기법 중 하나인 영지식증명에 대해서 소개하고자 한다.</p><p>우선 이 글을 읽을 대부분의 사람들에게 이름조차 생소할 영지식증명의 개념부터 설명하고자 한다. 영지식증명은 영어로 Zero-Knowledge Proof로 어떤 명제의 증명을 prover가 가지고 있다는 것을 proof에 대한 어떠한 정보도 verifier에게 넘기지 않고 verifier에게 확인시키는 암호 기법을 의미한다. 이해를 돕기 위해 예시를 들자면 Peggy라는 사람이 어떤 소고기가 미국산인지 한우인지 구별할 수 있는 기술을 개발했다고 하자. Peggy는 Victor에게 자신의 기술을 팔기 위해서 Victor에게 자신의 기술이 정확하다는 것을 보이고 싶지만 기술 그 자체를 알려주고 싶지 않아 한다. 이러한 상황을 해결하기 위해서 Victor가 미국산 소고기와 한우중 하나를 무작위로 가져오고 Peggy가 자신의 기술을 사용해서 그 고기가 한우인지 미국산인지 판단하여 Victor에게 말해준다. 이 Test를 시행하여 Peggy가 맞춘다면 Victor는 Peggy의 기술을 믿을 수 있을 것이다.</p><p>하지만 위의 예시를 읽다가 2가지 의문점이 생겼을 수도 있다. 우선 첫 번째는 과연 Peggy가 기술을 실제로 개발한 것이 아니라 단지 개발했다고 거짓말을 하고 있는 경우는 위의 test로 Peggy가 거짓말을 하고 있다고 판별할 수 있을까? 이며, 두 번째는 Victor가 테스트 과정에서 Peggy의 기술에 대한 정보를 얻을 수도 있지 않을까? 라는 의문일 것이다. 첫 번째 경우에서의 prover를 cheating하는 prover이므로 fake prover라 하고 두 번째 경우의 verifier를 cheating하는 verifier이므로 fake verifier라고 하자.</p><p>Fake prover의 cheating을 막기 위해서 어떻게 하면 될까? Fake prover의 목적은 자신이 기술을 가지고 있지 않지만 자신이 기술을 가지고 있는 것처럼 verifier에게 속이는 것이다. 그럼 fake prover와 prover를 구별해 낼 수 있는 둘의 차이를 생각해보자. Prover는 Victor가 준 어떤 소고기에 대해서 그 소고기의 원산지를 맞출 확률이 100%이지만 fake prover는 찍어서 맞출 확률이 50%라는 차이점이 있다. 이러한 차이점을 이용하여 Victor가 시행하는 test의 횟수를 늘려보자. 만약 Victor가 test를 시행하는 횟수를 n이라고 했을 때, fake prover가 모든 n번의 test를 찍어서 통과할 확률은 (0.5)$^n$이 되어 매우 작아진다는 것을 확인할 수 있다. 즉, 충분히 많은 test를 시행한다면 fake prover의 cheating이 성공할 확률을 0으로 수렴시킬 수 있어 cheating을 막을 수 있다.</p><p>그렇다면 fake verifier의 cheating은 어떻게 막을 수 있을까? Fake verifier의 목적은 자신이 서로가 합의를 한 test를 여러 번 시행하여 Peggy의 기술에 대한 정보를 알아내려는 것으로, fake verifier는 test의 결과를 분석하여 자신이 원하는 바를 이루어 내는 것을 막아야 한다. 사실 위의 예시의 경우에는 fake verifier의 cheating을 막기 쉽다. Prover인 Peggy가 fake verifier에게 소고기를 받아 자신의 기술을 써서 판별한 다음, 사용한 소고기는 버리는 식으로 (소고기 아깝다…..) fake verifier에게 fake verifier가 원래 알고 있었던 정보인 소고기의 원산지에 대한 정보만 넘겨줄 수 있다. 즉, fake verifier가 새로이 알게 되는 정보가 없으므로 Peggy의 기술에 대한 정보를 알 수 없다.</p><p>위의 예시에서 볼 수 있듯이 영지식증명은 다음의 3가지의 조건을 가지고 있으며, 다음의 조건들은 각각 completeness, soundness, zero-knowledge라고 불린다.</p><ul><li>Prover가 proof를 가지고 있을 경우에 verifier에게 그것을 확신시킬 수 있어야 한다.</li><li>Fake prover가 proof를 가지고 있다고 거짓말을 할 경우 verifier는 proof를 가지고 있지 않다는 것을 알 수 있어야 한다.</li><li>Fake verifier가 proof에 대해 추가로 알아낼 수 있는 정보는 없어야 한다.</li></ul><p>지금까지 영지식증명이 무엇인지 알아보았고, 영지식증명이 사용될 수 있는 간단한 예시도 살펴보았다. 하지만 과연 위와 같은 실생활 속의 예시에서 잘 성립이 된다고 해서 수학적 명제들이나 과학적 명제들에 대해서도 영지식증명이 잘 활용될 수 있을까? 라는 의문이 들 것이다. 수학적 명제들의 경우 전제와 결론 사이의 과정을 확인해야지만 그 명제의 증명을 알고 있다는 것을 보일 수 있으며, 과학적 명제의 경우에도 실험 결과를 제시하거나 증명을 제시해야 하기 때문이다. 그래서 앞에서 든 간단한 예시 이외에도 수학적 명제에 영지식증명을 활용하는 예시를 소개하고자 한다.</p><p>수학적 명제의 경우에는 유명한 문제인 그래프 3색 문제, Graph 3-colorability (앞으로는 G3C라고 표기하자)의 영지식증명을 소개하고자 한다. 우선 G3C 문제는 다음과 같이 정의된다.</p><ul><li>$f_{G3C}:G=(V,E) \rightarrow \{True, False\}$<br>where $f_{G3C}(G=(V,E))=True$ if $^{\exists} \phi:V\rightarrow[3]$, $^{\forall}(u,v)\in E$, $\phi(u)\ne\phi(v)$      </li></ul><p>쉽게 풀어 쓰자면 G3C는 어떤 그래프가 있을 때, 3개의 색만을 사용하여 그래프의 모든 인접한 node들을 서로 다른 색으로 칠할 수 있는지를 묻는 문제이다.</p><p>우선 prover와 verifier에게 동시에 주어진 정보가 $G=(V,E)$이고, prover에게 따로 주어진 정보인 valid 3-coloring인 $\phi : \rightarrow [3]$ of G. 이제 verifier가 다음 단계를 $|V||E|$번 반복하자.</p><ol><li>Prover는 random permutation $\pi \in S_{3}$을 고르고 verifier에게 $(C_{v}(\pi (\phi (v))))_{v\in V}$를 보낸다. (각각의 $C_{v}$ 는 각 node에 해당하는 commitment라고 불리는 암호이다.)</li><li>Verifier는 prover에게 무작위 edge $(u,v) \in E$를 보낸다.</li><li>Prover는 $C_{u}(\cdot)$과 $C_{v}(\cdot)$를 열 수 있는 key를 보낸다.</li><li>Verifier는 암호를 풀어 $a_{u} = \pi(\phi(u))$와 $a_{v} = \pi(\phi(v))$를 구한다.</li><li>Verifier는 $a_{u} \ne a_{v}$인지 확인한다.</li></ol><p>만약 $|V||E|$번의 test동안 $a_{u} \ne a_{v}$인 것을 확인한다면 verifier는 prover가 증명을 알고 있다고 믿을 수 있다.</p><p>위에서 서술한 과정이 과연 영지식증명의 3가지 조건을 만족할까? 우선 completeness부터 살펴보자. Completeness가 성립하기 위해서는 만약 prover가 valid 3-coloring을 알고 있다면 그것을 verifier에게 확신시킬 수 있어야 한다. 즉, 어떠한 edge $(u,v) \in E$를 골라도,  $\pi(\phi(u)) \ne \pi(\phi(v))$이어야 한다. 그런데 Prover가 가지고 있는 $\phi$는 valid 3-coloring이므로 $\phi(u)\ne\phi(v)$이므로 앞의 조건을 만족시켜줄 수 있다.</p><p>그렇다면 soundness를 만족할까? Soundness를 만족하기 위해서는 fake prover가 모든 test를 찍어서 통과할 확률을 충분히 작게 만들어야 한다. 그럼 우선 fake prover가 한 번의 test를 찍어서 통과할 확률은 얼마일까? Commitment scheme의 성질에 의하여 fake 3-coloring $\phi^{*}$을 가지고 있는 fake prover의 cheating이 걸릴 확률이 $\frac{1}{|E|}$이상이다. 그러므로 fake prover가 $|V||E|$번의 test를 모두 통과할 확률은 $(1-\frac{1}{|E|})^{|V||E|} \leq e^{-|V|}$보다 작고, $|V|$의 크기에 따라 확률이 충분히 작아질 수 있다. 즉, fake prover의 cheating을 막는 soundness를 만족한다.</p><p>마지막으로 Zero-knowledeness를 만족한다는 것을 보이기 전에 zero-knowledgeness의 비교적 엄밀한 정의를 설명하고자 한다. 모든 fake verifier에 대하여 어떤 TM(turing machine)이 존재하여 $\{\langle P, V^{*} \rangle (x)\}_{x \in L}$과 $\{M^{*}(x)\}_{x\in L} $가 computationally indistinguishable 하다면 computational zero-knowledge라고 한다. 이걸 좀 더 쉽게 설명하자면 어떤 simulator M이 있어서 fake verifier가 prover와 주고 받는 모든 내용을 simulate할 수 있다는 것이다. 즉, proof를 모르고 있는 어떤 simulator가 대화를 완벽히 재현할 수 있으므로 fake verifier가 영지식증명 과정에서 proof에 대한 아무런 정보도 얻을 수가 없다는 것이다.</p><p>다시 G3C문제로 돌아와서 위의 과정이 (computational) zero-knowledge를 만족한다는 것을 보이자. 어떤 fake verifier $V^{*}$에 대하여 다음을 과정으로 simulate한다면 fake verifier와 prover의 영지식증명을 simulate할 수 있다는 것을 알 수 있다.</p><ol><li>무작위로 $(u‘,v‘)\in E$를 고른다.</li><li>무작위로 $a‘_{u} \ne a’_{v}$인 $a’_{u}, a’_{v} \in [3]$을 고른다.</li><li>$^{\forall} w \in V\setminus\{u’,v’\}$에 대하여 $a’_{w}$를 1로 설정한다.</li><li>$(u,v)$를 $V^{*}$으로부터의 대답으로 설정한다.</li><li>만약 $(u,v) = (u’, v’)$이라면 두 색을 공개한다.</li><li>다르다면 위의 과정을 처음부터 다시 시행한다. 단 총 횟수가 $|V||E|$를 넘지 않게 한다.</li><li>$|V||E|$번의 반복 후에 simulator 과정에서 실패한 경우가 있다면 F를 return한다.</li></ol><p>예시로 사용된 Graph 3-colorability처럼 수많은 수학적 명제는 이와 같은 방식으로 영지식증명을 사용할 수 있다.</p><p>사실 영지식증명의 엄밀한 정의는 zero-knowledge의 조건을 설명할 때 사용한 probability를 이용한 정의를 가진다. 확률공간을 사용하여 정의된 영지식증명은 매우 어렵지만 관심이 있다면 밑의 첨부파일을 참고하길 바란다.</p><hr><p>첨부파일 ∣ <a href="/uploadfiles/Zero-Knowledge-Proof-lec12_zkp.pdf" target="\_blank"> lec12_zkp.pdf </a> ∣ <a href="/uploadfiles/Zero-Knowledge-Proof-prob_basic.pdf" target="\_blank"> prob_basic.pdf </a><br><i class="icon fa fa-exclamation"></i> 위 파일의 모든 저작권은 한국과학영재학교 윤상현 선생님께 있습니다.<br><i class="icon fa fa-exclamation"></i> 위 파일들은 허가 없이 변형, 복제 및 배포 등의 사용을 할 수 없습니다.</p><hr><p><strong style="font-size:1.2em;">16-045 박홍근</strong><br><strong class="nametag_bold">(Hong-Geun Park | Tony Park)</strong><br>– ㄴㄱㄴㄱㄴㄱ ㅇㅍㅇㅇㄷ / Programmer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:tonypark7277@naver.com" target="_blank" rel="noopener">tonypark7277@naver.com</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zero Knowledge Proof / 영지식증명&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-045 Hong-Geun Park" scheme="http://eosofksa.github.io/categories/KSA-16/16-045-Hong-Geun-Park/"/>
    
    
      <category term="Zero Knowledge Proof / 영지식증명" scheme="http://eosofksa.github.io/tags/Zero-Knowledge-Proof-%EC%98%81%EC%A7%80%EC%8B%9D%EC%A6%9D%EB%AA%85/"/>
    
  </entry>
  
  <entry>
    <title>게임으로 게임 만들기</title>
    <link href="http://eosofksa.github.io/2018/05/10/%EA%B2%8C%EC%9E%84%EC%9C%BC%EB%A1%9C-%EA%B2%8C%EC%9E%84-%EB%A7%8C%EB%93%A4%EA%B8%B0/"/>
    <id>http://eosofksa.github.io/2018/05/10/게임으로-게임-만들기/</id>
    <published>2018-05-09T15:47:45.000Z</published>
    <updated>2018-05-11T07:54:49.085Z</updated>
    
    <content type="html"><![CDATA[<p>게임으로 게임 만들기</p><a id="more"></a><p>게임을 제작한다고 하면 제작도구로 흔히 게임메이커, 유니티, RPG maker, 그리고 좀 더 깊게는 Unreal Engine, Java 등을 상상할 것이다. 하지만 아주 소수의 특~별한 사람들은 1990년에 SNES(Super Nintendo Entertainment System, 한국에서는 슈퍼패미콤으로 알려져 있음)에 출시된 ‘슈퍼 마리오 월드’를 상상할 것이다. 게임을 플레이함으로써 또 하나의 게임을 코딩할 수 있다는 사실이 이상하게 들릴 수도 있지만, 이를 처음으로 해낸 스피드러너 Sethbling을 비롯해, 많은 게이머들이 게임을 만드는 데 성공하였다. 이들은 게임 속에서 발견할 수 있는 각종 버그를 활용하여, 게임을 해킹하거나 치트 코드 혹은 에뮬레이터를 사용하지 않고, 단순히 게임과 게임기 있는 그대로를 가지고 Snake, Pong, 그리고 Flappy Bird과 같은 클래식 게임들을 재현해내었다.</p><video class="video-js vjs-default-skin" controls preload="auto" src="/videos/Game-made-by-game-Snake.mp4"></video><p>이러한 게임 제작은 어떻게 가능한 것인가? 과정을 일일이 설명하기엔 너무 복잡하고, 작성자가 그럴 시간도 없으니 간단하게 원리만 보이겠다.</p><p><img src="/images/Game-made-by-game-code.png" alt=""></p><p>위 사진에서 볼 수 있듯이, 게임 속 시스템에서의 모든 명령은 16진수 코드로 이루어진다. 스프라이트의 좌표에서부터 특정 값을 저장 및 불러오는 것, and, not 등의 연산자까지 다 16진수로 이루어진 값들을 읽어내어 게임을 플레이 할 수 있는 것이다. 이 중에 플레이어가 임의로 조작할 수 있는 값을 스프라이트들의 xy좌표가 있다.</p><p><img src="/images/Game-made-by-game-Sprite.gif" alt=""></p><p>위 화면에서의 예시와 같이, 슈퍼 마리오 월드는 한 화면에 대해 마리오를 제외하고는 총 12개의 스프라이트들(아이템, 요시, 적 포함)의 값까지만 처리한다. 지정 array의 각 스프라이트의 xy값들이 저장되며, 이러한 좌표값은 그 스프라이트를 가진 오브젝트가 사라진 이후에도 새로운 오브젝트가 나오지 않는 이상 저장된 상태를 유지한다. 이 array들이 플레이어가 게임을 통해 직접 값을 조정할 수 있다는 점을 통해 코드를 입력할 수 있는 것이다. 자 인제 값들을 넣었으니, 게임한테 이 값들이 스프라이트의 좌표값이 아닌 다른 코드라고 알려주기만 하면 된다!!</p><p><img src="/images/Game-made-by-game-Chuck.gif" alt=""></p><p>그걸 가능하게 하는 놈이 바로 이 놈이다. 요 놈의 이름은 Chargin Chuck으로, 적 캐릭터임에도 불구하고 아이템 클래스를 상속받고 있다. 쉽게 설명하자면, 게임이 얻을 수 있는 아이템으로 취급을 하고 있다는 것이다. 하지만 평소 게임플레이에서는 게임이 오브젝트가 아이템인지 판정하는 것보다 적인지 판정하는 것을 먼저 하기에 먹을 수 없다… 이를 해결하기 위해 요시를 이용해 버섯을 먹게 시킨 후, 바로 요시에서 내려 대신 버섯을 먹는다면, 요시로 하여금 그 위치에 대신 있는 Chuck을 먹게 할 수 있다!<br>이렇게 되면, 게임은 Chuck을 먹었을 때 무슨 커멘드를 내려야 할지 모르기 때문에 default위치의 코드로 이동하게 된다. 근데 우연히도 이 위치가 바로 우리가 아까 변형한 아이템들의 스프라이트 위치들을 저장한 코드이다. 즉, 스프라이트 위치값들을 좌표값이 아닌 실행코드로 봄으로써 그 안에 플레이어가 코딩한 게임을 실행할 수 있게 되는 것이 바로 이 난잡한 게임메이커의 결론이다.</p><p>참고)<div class="video-container"><iframe src="//www.youtube.com/embed/vAHXK2wut_I" frameborder="0" allowfullscreen></iframe></div></p><hr><p><strong style="font-size:1.2em;">16-065 윤요한</strong><br><strong class="nametag_bold">(Yo-Han Yoon | Johnny Youngster)</strong><br>– Youtuber / Music Producer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:yohanme@naver.com" target="_blank" rel="noopener">yohanme@naver.com</a></i>, <i class="icon fa fa-youtube-play" style="font-size:1em;"> <a href="https://www.youtube.com/channel/UCQ7yoYi-qvppChAIlbLalAQ" target="_blank" rel="noopener">Johnny Youngster</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;게임으로 게임 만들기&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-065 Yo-Han Yoon" scheme="http://eosofksa.github.io/categories/KSA-16/16-065-Yo-Han-Yoon/"/>
    
    
      <category term="Game" scheme="http://eosofksa.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 블로그에 카카오링크 추가하기</title>
    <link href="http://eosofksa.github.io/2018/05/09/Share-On-Kakaotalk/"/>
    <id>http://eosofksa.github.io/2018/05/09/Share-On-Kakaotalk/</id>
    <published>2018-05-09T13:12:58.000Z</published>
    <updated>2018-05-11T16:52:14.426Z</updated>
    
    <content type="html"><![CDATA[<p>상황은 이해가 가지만 참 힘들게 한다.</p><a id="more"></a><h2 id="2018-05-09"><a href="#2018-05-09" class="headerlink" title="2018.05.09"></a>2018.05.09</h2><h4 id="들어가기-전에…"><a href="#들어가기-전에…" class="headerlink" title="들어가기 전에…"></a>들어가기 전에…</h4><p>글의 기본 공유는 Twitter, Facebook, Pinterest, Google+ 총 4가지로 제공되어있다. 그러나 우리나라에서는 Pinterest나 Google+보다 카카오톡을 통한 공유가 더 활발히 이루어지고 있다. 이에 카카오톡 공유를 만들어보기로 하였다. 보통 개발일지를 남길 때에는 개발을 쭈욱 하고 열었던 페이지들 중에 기록해 놓아야 할 링크들을 남기는 식으로 작성하는데, 이번엔 찾다찾다 못 찾아서 결국 혼자 한 부분도 있어 설명을 적어야 할 것 같다. (게다가 어떤 페이지를 열었는지도 기억이 안 난다.) 어쨌든 글이 두서 없을 수 있음을 미리 경고한다.</p><p>카카오톡에 링크를 공유하는 것은 카카오링크라는 이름의 api로 카카오에서 지원하고 있다.</p><p>EOS의 경우 이전에 더치페이 계산 카카오톡 봇을 만들기 위해 EOS 이름의 카카오 계정을 만든 적이 있어 이 계정으로 연결하였다. <del>그러나 정작 그 프로젝트는 흔적도 없이 소멸…</del></p><p>참고) [ <a href="http://prolite.tistory.com/1201" target="_blank" rel="noopener">http://prolite.tistory.com/1201</a> ]</p><ul><li>카카오 쪽 처리가 매우 잘 정리되어 있다. 앞에서 혼자 다 한 것처럼 써놓긴 했지만 이 블로그가 반은 해준 것 같다. 위 블로그 글을 따라가다 보면 17번과 19번 사이에 번호가 안 매겨진 암묵적 18번이 있다. 그 부분이 문제가 되었는데, hexo 블로그는 기본적으로 <code>.ejs</code>로 구성되며 이 파일을 통해서 html과 js를 모두 생성하는 구조인데, 직접 넣어야 하는 이 상황은 EJS에 뉴비인 본인을 당황시키기에 충분했다.</li></ul><h4 id="1차-삽질"><a href="#1차-삽질" class="headerlink" title="1차 삽질"></a>1차 삽질</h4><p>이 문제를 해결하기 위한 본격적인 삽질에 앞서 <code>themes/hueman</code> 폴더 안의 파일들을 싹 다 뜯어보았다. (필요한 폴더/파일만 명시)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">themes</span><br><span class="line">└── hueman</span><br><span class="line">    └── layout</span><br><span class="line">        ├── common</span><br><span class="line">        │   ├── article.ejs</span><br><span class="line">        │   └── head.ejs</span><br><span class="line">        ├── _partial</span><br><span class="line">        │   └── article.styl</span><br><span class="line">        ├── share</span><br><span class="line">        │   ├── index.ejs</span><br><span class="line">        │   └── default.ejs</span><br><span class="line">        └── source</span><br><span class="line">            └── css</span><br><span class="line">                └── _variables.styl</span><br></pre></td></tr></table></figure></p><p><code>default.ejs</code>를 보면,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = [</span><br><span class="line">    <span class="string">'&lt;div id="'</span> + id + <span class="string">'" class="article-share-box"&gt;'</span>,</span><br><span class="line">        <span class="string">'&lt;input class="article-share-input" value="'</span> + url + <span class="string">'"&gt;'</span>,</span><br><span class="line">        <span class="string">'&lt;div class="article-share-links"&gt;'</span>,</span><br><span class="line">            <span class="string">'&lt;a href="https://twitter.com/intent/tweet?url='</span> + encodedUrl + <span class="string">'" class="article-share-twitter" target="_blank" title="Twitter"&gt;&lt;/a&gt;'</span>,</span><br><span class="line">            <span class="string">'&lt;a href="https://www.facebook.com/sharer.php?u='</span> + encodedUrl + <span class="string">'" class="article-share-facebook" target="_blank" title="Facebook"&gt;&lt;/a&gt;'</span>,</span><br><span class="line">            <span class="string">'&lt;a href="http://pinterest.com/pin/create/button/?url='</span> + encodedUrl + <span class="string">'" class="article-share-pinterest" target="_blank" title="Pinterest"&gt;&lt;/a&gt;'</span>,</span><br><span class="line">            <span class="string">'&lt;a href="https://plus.google.com/share?url='</span> + encodedUrl + <span class="string">'" class="article-share-google" target="_blank" title="Google+"&gt;&lt;/a&gt;'</span>,</span><br><span class="line">        <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">].join(<span class="string">''</span>);</span><br></pre></td></tr></table></figure></p><p>을 발견할 수 있다. 그렇다면 카톡도 저런 링크를 찾으면 되겠다! 라는 희망을 품고 다른 대안을 찾기 위해 <a href="https://developers.kakao.com" target="_blank" rel="noopener">KakaoDevelopers_</a>를 들어가 보았다. 그리고 절망을 보았다.</p><p><a href="https://developers.kakao.com/docs/js/kakaotalklink" target="_blank" rel="noopener">https://developers.kakao.com/docs/js/kakaotalklink</a></p><ul><li>카카오톡 공유 형태의 다양한 버전이 제시되어 있고 각각의 javascript 코드가 제시되어 있다. 역시나 <strong>저런</strong> URL은 없었다. 뭐 어쨌든 코드를 보면 넣어줘야 하는 정보들이 많은 레이아웃이 있고 적은 레이아웃이 있다. 이 페이지의 경우 스크랩 템플릿이 가장 적합할 것으로 판단되어 이를 사용하기로 하였다. (절대로 요구하는 Argument의 수가 제일 적어서는 아니다)</li></ul><p>일단 기본 상식 선에서 href에 <code>javascript:sendLink(arg)</code>의 형태로 처리하면 될지도 모른다는 판단이 섰다. 그러면 이제 문제가 되는 부분은 저 스크립트를 어디에 어떻게 넣어야 하는가이다. 이 때 구조 삽질이 빛을 발하는데, 최종적으로 생성되는 html의 글 부분은 <code>article.ejs</code>이 결정한다. 공유와 관련한 부분을 찾아보면<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-footer"</span>&gt;</span><br><span class="line">    &lt;%- partial(<span class="string">'share/index'</span>, &#123; <span class="attr">post</span>: post &#125;) %&gt;</span><br><span class="line">&lt;<span class="regexp">/footer&gt;</span></span><br></pre></td></tr></table></figure></p><p>을 발견할 수 있다. 즉, <code>share/index.ejs</code>가 연결됨을 알 수 있다. 그래서 보면<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!theme.share || theme.share === <span class="string">'default'</span>) &#123; %&gt;</span><br><span class="line">    &lt;%- partial(<span class="string">'default'</span>, &#123; <span class="attr">post</span>: post &#125;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>부분만 쓸 만하다. Hexo 개발자가 대만인이다 보니 중국계열 SNS가 많은데 이 부분 처리를 위해 있는 것 같다. 아무튼 결국 다시 <code>default.ejs</code>로 돌아왔다. 정리하면 <code>article.ejs</code>안에 다 포함되어 있는건데, 그래서 <code>&lt;%- partial(‘share/index’, { post: post }) %&gt;</code> 앞에 넣었더니 안 된다. 왠지는 아직도 모르겠다.</p><h4 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h4><p>해결책을 찾기 위해 기본으로 돌아가자는 마음으로 HTML을 처음 배울 적을 회상해봤다. 문득 머리를 스치는 한 가지</p><blockquote><p>script는 왠만하면 head에 import하라</p></blockquote><p>그래서 <code>head.ejs</code>로 갔다. 아래에 보니 js를 import하는 구간이 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- js(<span class="string">'libs/jquery/2.0.3/jquery.min'</span>) %&gt;</span><br><span class="line">&lt;%- partial(<span class="string">'plugin/scripts'</span>, &#123; <span class="attr">isHead</span>: <span class="literal">true</span> &#125;) %&gt;</span><br></pre></td></tr></table></figure></p><p>신나서 넣었다. 됐다!<br>+) 여담으로 중간에 뭘 잘못했는지 deploy 이후에 css가 깨지는 문제가 발생했다. 아마 붙여넣는 부분에서 뭔가를 잘라먹고 붙였던 것 같다. 한순간 멘탈이 박살 났지만 부여잡고 롤백하고 차분하게 하나씩 했더니 됐다.</p><h4 id="외관"><a href="#외관" class="headerlink" title="외관"></a>외관</h4><p>여하튼 그래서 저 <code>default.ejs</code>에<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&lt;a href=&quot;javascript:sendLink(\&apos;&apos; + url + &apos;\&apos;)&quot; class=&quot;article-share-kakaotalk&quot; target=&quot;_blank&quot; title=&quot;Kakaotalk&quot;&gt;&lt;/a&gt;&apos;</span><br></pre></td></tr></table></figure></p><p>를 추가해주었더니 <code>article-share-kakaotalk</code>이 없다.(;;;)</p><p>그래서 <code>article-share-facebook</code>를 찾아서 <code>article.styl</code>을 보니 비교적 구조가 단순하길래 복붙해서 하나 만들고 보니 아이콘이 애매했다. font-awesome 아이콘들은 대체로 fa-XXX로 표현되는데 <code>\f0XX</code>형태라서 살짝 당황했지만 인터넷에 표를 찾아보니 금방 나오더라. 카톡 아이콘은 없기에 비슷한 말풍선 모양인 comment(\f075)로 결정<br>색은 <code>color-XXX</code>로 되어있길래 어디에 있나 했더니 <code>_varaibles.styl</code>에 있길래 카톡 아이콘 끌어다놓고 노란색 따서 color-kakaotalk을 만들었다. 노란색 해보니 안 카톡스러운 것 같아 갈색으로 바꿀까 생각 중…</p><p>참고)<br>article.styl<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article-share-kakaotalk</span></span><br><span class="line">    @<span class="keyword">extend</span> $article-share-link</span><br><span class="line">    &amp;:before</span><br><span class="line">        content: <span class="string">"\f075"</span></span><br><span class="line">    &amp;:hover</span><br><span class="line">        background: color-kakaotalk</span><br><span class="line">        text-shadow: <span class="number">0</span> <span class="number">1px</span> darken(color-kakaotalk, <span class="number">20%</span>)</span><br></pre></td></tr></table></figure></p><p>_variables.styl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">color-twitter = #00aced</span><br><span class="line">color-facebook = #3b5998</span><br><span class="line">color-pinterest = #cb2027</span><br><span class="line">color-google = #dd4b39</span><br><span class="line">color-kakaotalk = #ffeb33</span><br></pre></td></tr></table></figure></p><p>여담으로, 로컬서버에서 테스트하는 경우 카카오톡이 동작하지 않을 수 있다. 401에러가 발생하게 되는데 이는 카카오 서버에 등록한 URL과 다른 주소(127.0.0.1)에서 발생한 정보이기 때문에 Unauthorized로 판단하는 것이다.</p><p><img src="/images/Share-On-Kakaotalk-Page_Capture.png" alt="여기서 이렇게 누르면"><br><img src="/images/Share-On-Kakaotalk-Kakaotalk_Capture.png" alt="결과는 이렇다"></p><h2 id="2018-05-10"><a href="#2018-05-10" class="headerlink" title="2018.05.10"></a>2018.05.10</h2><blockquote><p>당연히 모바일도 되겠지 하고 있었는데 안 되는걸 발견…ㅜ<br>놀랍게도 카카오 측 응답이 에러 사인이 아니라 해결하는데 시간이 좀 걸릴 것 같다.</p></blockquote><p>폰으로 들어가서 안 뜨는걸 보고 절망하고 있었는데 떴다. 그냥 크사파이가 느렸던걸로…<br>여튼 인터넷이 느리면 카톡이 로딩되는 속도도 영향을 받는 듯 하다.</p><p>카톡 아이콘 노란색은 볼수록 괜찮아서 일단 두기로 했다.</p><hr><p><strong style="font-size:1.2em;">16-077 이원준</strong><br><strong class="nametag_bold">(Won-Joon Lee | sni/J)</strong><br>– 그림 그리는 개발자 / Designer and Web Designer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:wjl0316@naver.com" target="_blank" rel="noopener">wjl0316@naver.com</a></i>, <i class="icon fa fa-instagram" style="font-size:1em;"> <a href="https://instagr.am/sniperj_got_ya_back" target="_blank" rel="noopener">sniperj_got_ya_back</a></i>, <i class="icon fa fa-facebook" style="font-size: 1em;"> <a href="https://facebook.com/wonjoonlee0316" target="_blank" rel="noopener">WonJoonLee0316</a></i>, <i class="icon fa fa-github" style="font-size: 1em;"> <a href="https://github.com/sni-j" target="_blank" rel="noopener">sni-J</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;상황은 이해가 가지만 참 힘들게 한다.&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-077 Won-Joon Lee" scheme="http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"/>
    
    
      <category term="DevLog" scheme="http://eosofksa.github.io/tags/DevLog/"/>
    
  </entry>
  
  <entry>
    <title>자동 정리 증명의 간단한 아이디어</title>
    <link href="http://eosofksa.github.io/2018/05/09/Automatic-Theorem-Proving-Intro/"/>
    <id>http://eosofksa.github.io/2018/05/09/Automatic-Theorem-Proving-Intro/</id>
    <published>2018-05-09T12:52:00.000Z</published>
    <updated>2018-05-10T03:10:04.453Z</updated>
    
    <content type="html"><![CDATA[<p>KSATP 연구회 부스도 많이 오세요</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>자동정리증명은 자동으로 정리(Theorem)를 증명하는 알고리즘에 관한 문제이다. 어떠한 공리와 명제를 입력 받고 증명 시스템을 입력 받으면 증명 시스템을 이용하여 공리로부터 명제를 이끌어 내는 것이다. 이러한 것이 가능한 이유는 공리의 개수가 유한하고(개수가 무한히 많은 공리도 있으나 유한한 공리로 바꿀 수 있을 것이다) 증명 시스템 또한 유한하므로 이들을 잘 조합하면 알고리즘도 증명을 하는 것이 가능하다는 것을 알 수 있을 것이다. 자동정리증명은 세가지 부류로 나눌 수 있는데 일반적인 자동정리증명과 Human-readable, 그리고 Interactive가 있다. 일반적인 자동정리증명은 알고리즘이 자동으로 증명을 해주나 증명 과정을 사람이 보고 이해하는 것이 쉽지 않아 Provable을 판단하는 용도로 제한된다. Human-readable은 사람이 읽을 수 있는 증명 과정을 제공해주는데 이 과정이 복잡하여 효율이 떨어진다. Interactive Theorem Proving은 Proof Assistant라고도 불리는데 사람과 상호작용하여 자잘하고 증명하기 까다로운 Lemma는 자동정리증명이 증명을 해주고 전체적인 증명 흐름은 사람이 짜는 형태이다. 현재 수학 학회에서 널리 사용되는 자동증명검증 프로그램 Coq도 Interactive Theorem Proving이 가능하다.</p><h2 id="NP-Completeness"><a href="#NP-Completeness" class="headerlink" title="NP-Completeness"></a>NP-Completeness</h2><p>자동정리증명은 유명한 NP-complete 문제 중 하나이다. 이를 확인하기 위해서는 자동정리증명이 NP이고 NP-hard인지 확인해야 하는데, NP-hard임은 SAT으로부터의 환원(reduction)을 쉽게 구성할 수 있으므로 자명하다. NP임을 보이는 방법은 여러가지가 있는데 정의에 입각하여 증명하는 편이 쉽다. 자동정리증명의 검증자(certifier) 알고리즘은 어떠한 정리와 증명을 입력받으면 알맞는 증명인지 확인하는 알고리즘일 것이다. 이 알고리즘은 다항 시간(poly-time)안에 가능함이 이미 증명되었고 Coq라는 유명한 프로그램도 있다. 따라서 자동정리증명은 NP-complete이고 이에 따라 사람들은 보통 자동정리증명의 다항시간 알고리즘을 찾지 않는다.</p><h2 id="First-Order-Logic"><a href="#First-Order-Logic" class="headerlink" title="First Order Logic"></a>First Order Logic</h2><p>First Order Logic(일차 논리)란, quantifier가 variable에만 허용되는 논리로 특정 언어를 지칭하는 것이 아니라 언어들의 성격에 따라 분류한 하나의 집합으로 생각해야 한다. 일차 논리 이외에도 이차 논리, 고차 논리도 있는데 이들은 relation과 function에도 quantifier가 붙는 것을 허용하는 논리다. 또 영차 논리도 있는데 영차 논리는 quantifier가 허용되지 않는 단순한 형태의 언어다. 이 문서에서 서술할 모든 논리학적 성질은 전부 일차 논리에 근거하여 작성할 것이다.</p><p>일차 논리인 특정한 언어는 두 가지로 나누어서 생각할 수 있는데 proof system과 syntax다. Syntax는 특정 언어가 다른 일차 논리와 다르게 이 언어에서만 사용되는 기호들을 의미한다. 예를 들어 덧셈의 + 기호는 집합에서 사용되지 않으므로 syntax라고 할 수 있다. 두번째로 proof system는 가장 중요하다고 할 수 있는데 Theory(어떠한 formula로 axiom과 같은 의미다. 이 문서에서는 Theorem과 Theory로 나누어서 사용하겠다.)로부터 Theorem을 이끌어내는 추론 방식이다. 유명한 proof system에는 Hilbert style과 Natural Deduction(Sequent Calculus)등이 있는데 우리가 일반적으로 알고 있는 proof system이 Natural Deduction이므로 이 문서에서는 Natural Deduction을 가정하고 작성하겠다.</p><p>이제 일차 논리의 성질들에 대해서 알아보자.<br>We said $\mathcal{L}$-theory $\mathcal{T}$ is consistent, $Con(\mathcal{T})$, if there is no $A \in \mathcal{L} _ {S}$ s.t. $\mathcal{T} \vdash A$ and $\mathcal{T} \vdash \neg A$.<br>Also, we said $\mathcal{L}$-theory $\mathcal{T}$ is complete if for $^{\forall} A\ \in \mathcal{L}_{S}$, $\mathcal{T} \vdash A$ or $\mathcal{T} \vdash \neg A$, but not both.</p><p>즉 어떤 Theory $\mathcal{T}$가 complete하면 consistent를 만족하는 것이다.<br>그런데 괴델의 불완전성 정리에 의하면 모든 일차 논리의 Theory는 complete하지 않는다.<br>즉, 항상 Theory와 independent한, 증명불가능인, Theorem이 존재한다는 것이다.<br>그래서 일반적으로 자동정리증명 프로그램은 증명 불가능한 명제를 고려하지 않는다.<br>증명불가능의 예시를 보기 위해 ZFC에 대해 알아보자.</p><h2 id="ZFC"><a href="#ZFC" class="headerlink" title="ZFC"></a>ZFC</h2><p>ZFC(Zermelo–Fraenkel with axiom of Choice)는 가장 유명한 집합 공리계로 유한한 공리계의 대표 예시라고 할 수 있다. ZFC에는 확장 공리(axiom of extensionality), 정칙성 공리(axiom of regularity), 짝 공리(axiom of pairing), 합집합 공리(axiom of union), 멱집합 공리(axiom of power set), 무한 공리(axiom of infinity), 분류 공리꼴(axiom schema of specification), 치환 공리꼴(axiom schema of replacement), 그리고 선택 공리(axiom of choice)로 이루어져있다. 사실 집합 공리의 경우 간단하게 표현이 가능하지 않을까라고 생각하기 쉽지만 Russel의 패러독스를 보면 생각이 바뀔 것이다. 이렇게 수학자들이 고심하여 열심히 만든 공리계 ZFC조차 증명 불가능한 Theorem들이 있는데 대표적인 예시가 연속체 가설(continuum hypothesis)이다. 이 문제는 자연수 집합의 크기와 실수 집합의 크기 사이의 크기를 가지는 무한 집합이 존재하는 가에 대한 문제로(또는 $2^{\aleph_0}=\aleph_1$으로 이해할 수도 있다.) 증명불가능이 증명되었다.</p><p>만약 이 글을 읽고 자동정리증명에 흥미가 생겼다면 이번 SAF의 KSATP 부스에서 더 자세한 설명을 들을 수 있다.</p><hr><p><strong style="font-size:1.2em;">16-010 김기환</strong><br><strong class="nametag_bold">(Ki-Hwan Kim | atheNa)</strong><br>– Follower of Blizzard corp. / Security Operator and Programmer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:jerry010222@naver.com" target="_blank" rel="noopener">jerry010222@naver.com</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KSATP 연구회 부스도 많이 오세요&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-010 Ki-Hwan Kim" scheme="http://eosofksa.github.io/categories/KSA-16/16-010-Ki-Hwan-Kim/"/>
    
    
      <category term="ATP (Automatic Theorem Proving)" scheme="http://eosofksa.github.io/tags/ATP-Automatic-Theorem-Proving/"/>
    
  </entry>
  
  <entry>
    <title>게임 잡학 퀴즈</title>
    <link href="http://eosofksa.github.io/2018/05/09/Game-quizzes/"/>
    <id>http://eosofksa.github.io/2018/05/09/Game-quizzes/</id>
    <published>2018-05-09T11:06:00.000Z</published>
    <updated>2018-05-10T00:02:44.013Z</updated>
    
    <content type="html"><![CDATA[<p>게임 잡학 퀴즈! SAF 기간 동안 답을 적어서 EOS 16에게 보내주시면 소정의 상품을 드립니다!<br><a id="more"></a></p><h4 id="Q1-다음-중-가장-많은-수익을-올린-게임-IP-Information-Property-지적-재삭권-은-무엇일까"><a href="#Q1-다음-중-가장-많은-수익을-올린-게임-IP-Information-Property-지적-재삭권-은-무엇일까" class="headerlink" title="Q1: 다음 중 가장 많은 수익을 올린 게임 IP(Information Property; 지적 재삭권)은 무엇일까?"></a>Q1: 다음 중 가장 많은 수익을 올린 게임 IP(Information Property; 지적 재삭권)은 무엇일까?</h4><p>  (1)    테트리스<br>  (2)    슈퍼마리오<br>  (3)    마인크래프트<br>  (4)    히어로즈 오브 더 스톰<br>  (5)    히어로즈 오브 더 스톰<br>  (6)    히어로즈 오브 더 스톰</p><h4 id="Q2-테트리스-제작자-Alexey-Pajitnov가-1984년에-테트리스-제작-이후-10년동안-번-돈은-얼마-정도가-될까"><a href="#Q2-테트리스-제작자-Alexey-Pajitnov가-1984년에-테트리스-제작-이후-10년동안-번-돈은-얼마-정도가-될까" class="headerlink" title="Q2: 테트리스 제작자 Alexey Pajitnov가 1984년에 테트리스 제작 이후 10년동안 번 돈은 얼마 정도가 될까?"></a>Q2: 테트리스 제작자 Alexey Pajitnov가 1984년에 테트리스 제작 이후 10년동안 번 돈은 얼마 정도가 될까?</h4><p>  (1) 10만 달러 이상<br>  (2) 1만 달러 이상 10만 달러 이하<br>  (3) 100 달러 이상 1만 달러 이하<br>  (4) 100 달러 이하</p><h4 id="Q3-다음-중-현재-진행되고-있는-시리즈-중-가장-오래된-게임-시리즈는"><a href="#Q3-다음-중-현재-진행되고-있는-시리즈-중-가장-오래된-게임-시리즈는" class="headerlink" title="Q3: 다음 중 현재 진행되고 있는 시리즈 중 가장 오래된 게임 시리즈는?"></a>Q3: 다음 중 현재 진행되고 있는 시리즈 중 가장 오래된 게임 시리즈는?</h4><p>  (1)    갤러그<br>  (2)    스페이스 인베이더<br>  (3)    슈퍼 마리오<br>  (4)    스타크래프트</p><h4 id="Q4-다음-중-가장-처음으로-디자인된-포켓몬은"><a href="#Q4-다음-중-가장-처음으로-디자인된-포켓몬은" class="headerlink" title="Q4: 다음 중 가장 처음으로 디자인된 포켓몬은?"></a>Q4: 다음 중 가장 처음으로 디자인된 포켓몬은?</h4><p>  (1)    피카츄<br>  (2)    푸린<br>  (3)    이상해씨<br>  (4)    코뿌리</p><h4 id="Q5-다음-중-실사-영화화가-되지-않은-게임-시리즈는"><a href="#Q5-다음-중-실사-영화화가-되지-않은-게임-시리즈는" class="headerlink" title="Q5: 다음 중 실사 영화화가 되지 않은 게임 시리즈는?"></a>Q5: 다음 중 실사 영화화가 되지 않은 게임 시리즈는?</h4><p>  (1)    슈퍼 마리오 브라더스<br>  (2)    스트리트 파이터<br>  (3)    레지덴트 이빌<br>  (4)    포켓몬스터</p><h4 id="Q6-다음-중-게임-시장에-게임-국제-ESRB-나이-제한제-를-처음-도입하게-한-게임은"><a href="#Q6-다음-중-게임-시장에-게임-국제-ESRB-나이-제한제-를-처음-도입하게-한-게임은" class="headerlink" title="Q6: 다음 중 게임 시장에 게임 국제 ESRB(나이 제한제)를 처음 도입하게 한 게임은?"></a>Q6: 다음 중 게임 시장에 게임 국제 ESRB(나이 제한제)를 처음 도입하게 한 게임은?</h4><p>  (1) 모탈 컴뱃<br>  (2) 레지던트 이블<br>  (3) GTA<br>  (4) 슈퍼 메트로이드</p><h4 id="Q7-카즈미-토타카는-1990년부터-현재까지-닌텐도의-수많은-게임들의-음향-감독을-맡아왔다-그가-감독한-게임은-‘토타카의-테마’라는-곡이-게임-어딘가에-숨겨져-있는-것으로-유명하다-다음의-토타카가-음향-감독을-맡은-게임들-중-‘토타카의-테마’가-수록되지-않은-게임은"><a href="#Q7-카즈미-토타카는-1990년부터-현재까지-닌텐도의-수많은-게임들의-음향-감독을-맡아왔다-그가-감독한-게임은-‘토타카의-테마’라는-곡이-게임-어딘가에-숨겨져-있는-것으로-유명하다-다음의-토타카가-음향-감독을-맡은-게임들-중-‘토타카의-테마’가-수록되지-않은-게임은" class="headerlink" title="Q7: 카즈미 토타카는 1990년부터 현재까지 닌텐도의 수많은 게임들의 음향 감독을 맡아왔다. 그가 감독한 게임은 ‘토타카의 테마’라는 곡이 게임 어딘가에 숨겨져 있는 것으로 유명하다. 다음의 토타카가 음향 감독을 맡은 게임들 중 ‘토타카의 테마’가 수록되지 않은 게임은?"></a>Q7: 카즈미 토타카는 1990년부터 현재까지 닌텐도의 수많은 게임들의 음향 감독을 맡아왔다. 그가 감독한 게임은 ‘토타카의 테마’라는 곡이 게임 어딘가에 숨겨져 있는 것으로 유명하다. 다음의 토타카가 음향 감독을 맡은 게임들 중 ‘토타카의 테마’가 수록되지 않은 게임은?</h4><p>  (1)    요시 아일랜드<br>  (2)    대난투 스매시 브라더스 X<br>  (3)    Wii 스포츠<br>  (4)    놀러오세요 동물의 숲</p><h4 id="Q8-다음-중-GOTY-Game-of-The-Year-후보에-든-적이-한번도-없는-게임은"><a href="#Q8-다음-중-GOTY-Game-of-The-Year-후보에-든-적이-한번도-없는-게임은" class="headerlink" title="Q8: 다음 중 GOTY(Game of The Year) 후보에 든 적이 한번도 없는 게임은?"></a>Q8: 다음 중 GOTY(Game of The Year) 후보에 든 적이 한번도 없는 게임은?</h4><p>  (1)    다크 소울 2<br>  (2)    소닉 붐<br>  (3)    하스스톤<br>  (4)    페르소나 5</p><h4 id="Q9-다음-중-스트리밍-서비스로-유명한-트위치에서-스트리밍-금지-목록에-수록된-게임은"><a href="#Q9-다음-중-스트리밍-서비스로-유명한-트위치에서-스트리밍-금지-목록에-수록된-게임은" class="headerlink" title="Q9: 다음 중 스트리밍 서비스로 유명한 트위치에서 스트리밍 금지 목록에 수록된 게임은?"></a>Q9: 다음 중 스트리밍 서비스로 유명한 트위치에서 스트리밍 금지 목록에 수록된 게임은?</h4><p>  (1)    얀데레 시뮬레이터<br>  (2)    GTA 5<br>  (3)    단간론파 V3<br>  (4)    갓 오브 워: 어센션</p><h4 id="Q10-2014년-Carrie-Swidecki는-138시간-34초동안-쉬지-않고-‘이-게임’을-플레이-함으로써-기네스북-기록을-달성하였다-‘이-게임’은"><a href="#Q10-2014년-Carrie-Swidecki는-138시간-34초동안-쉬지-않고-‘이-게임’을-플레이-함으로써-기네스북-기록을-달성하였다-‘이-게임’은" class="headerlink" title="Q10. 2014년 Carrie Swidecki는 138시간 34초동안 쉬지 않고 ‘이 게임’을 플레이 함으로써 기네스북 기록을 달성하였다. ‘이 게임’은?"></a>Q10. 2014년 Carrie Swidecki는 138시간 34초동안 쉬지 않고 ‘이 게임’을 플레이 함으로써 기네스북 기록을 달성하였다. ‘이 게임’은?</h4><p>  (1) 팀 포트리스 2<br>  (2) 캔디 크러시<br>  (3) 월드 오브 워크래프트<br>  (4) Just Dance</p><hr><p><strong style="font-size:1.2em;">16-065 윤요한</strong><br><strong class="nametag_bold">(Yo-Han Yoon | Johnny Youngster)</strong><br>– Youtuber / Music Producer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:yohanme@naver.com" target="_blank" rel="noopener">yohanme@naver.com</a></i>, <i class="icon fa fa-youtube-play" style="font-size:1em;"> <a href="https://www.youtube.com/channel/UCQ7yoYi-qvppChAIlbLalAQ" target="_blank" rel="noopener">Johnny Youngster</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;게임 잡학 퀴즈! SAF 기간 동안 답을 적어서 EOS 16에게 보내주시면 소정의 상품을 드립니다!&lt;br&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-065 Yo-Han Yoon" scheme="http://eosofksa.github.io/categories/KSA-16/16-065-Yo-Han-Yoon/"/>
    
    
      <category term="Game" scheme="http://eosofksa.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>네트워크 통신에서의 데이터 무결성 검사</title>
    <link href="http://eosofksa.github.io/2018/05/08/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%86%B5%EC%8B%A0%EC%97%90%EC%84%9C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EA%B2%80%EC%82%AC/"/>
    <id>http://eosofksa.github.io/2018/05/08/네트워크-통신에서의-데이터-무결성-검사/</id>
    <published>2018-05-08T04:47:33.000Z</published>
    <updated>2018-05-09T15:33:29.818Z</updated>
    
    <content type="html"><![CDATA[<p>네트워크 통신에서의 데이터 무결성 검사 ··· Checksum</p><a id="more"></a><h2 id="INTRO"><a href="#INTRO" class="headerlink" title="INTRO"></a>INTRO</h2><p>누구나 컴퓨터는 0과 1로 이루어져 있다는 이야기를 들어본 적이 있을 것이다. 실제로 모든 디지털 정보는 0과 1의 조합을 통해 표현된다. 우리가 어떤 문자를 이용해 정보를 기록하는 것과 같은 이치로 볼 수 있는데, 그 이해를 위해 두 가지 간단한 예를 들어보겠다.</p><p>먼저, 사람이 사용하는 문장을 0과 1로 바꾸어보자. 만약 a부터 e까지 다섯 개의 알파벳을 a: 000 / b: 001 / c: 01 / d: 10 / e: 11 와 같이 대응시킨다면, ‘abbdca’라는 문장은 ‘0000010011001000’로, 거꾸로 ‘0000010011001000’라는 문장은 위 대응 관계에 근거하여 ‘abbdca’로 유일하게 해석됨을 직접 확인할 수 있다.</p><p>이번에는 어떤 명령들을 0과 1로 나타내보자. 4가지 명령 ‘앉아’, ‘일어서’, ‘왼손’, ‘오른손’을 최대한 짧은 길이의 문장으로 겹치지 않게 표현하기 위해선 최소 4가지의 경우를 나타낼 수 있는 0과 1의 조합을 생각해야한다. 이 경우에는 2-bit 만을 이용하여 00, 01, 10, 11 네 가지 경우를 각 명령에 대응 시킬 수 있으며, 해석하는 입장에서는 각 bit의 값을 보고 즉각 어떤 명령인지 알 수 있을 것이다.</p><p>우리가 매일 사용하는 전자기기들은 매 순간 이러한 문장들을 저장하고, 컴퓨터의 중추 CPU에서는 0과 1로 표현된 정해진 길이의 명령들을 1초에 수억번에서 수십억번 가까이 처리하고 있다. 특히 전자기기가 일반인들에게 널리 보급되고, 모든 분야에서 컴퓨터가 사용되고 있으며, 네트워크가 상상할 수 없는 규모로 확장된 지금 사회에선 매 순간 엄청난 양의 정보들이 이동하고 있다.</p><p>여기서 한 가지 의문이 든다. 0과 1로만 이루어진 정보를 무선 통신으로 주고 받는데, 우리의 스마트폰과 노트북은 지구 반대편에서 보낸 정보 조차 한치의 오차 없이 받아낸다. 데이터의 결함은 그 규모에 상관 없이 큰 골칫거리인게, 위에서 예로 든 ‘0000010011001000’를 전송하는 도중 통신의 장애로 인해 ‘0000000011001000’으로 받아진다면 그 의미는 ‘abbdca’가 아닌 ‘aabdca’로 완전히 다른 뜻이 되어버린다. 전송하는 문장이 어떤 명령이라면 시스템 자체에 결함이 생기는 것이다.</p><p>하지만 당장 비가 오는 날 축구 생중계를 볼 때만 해도 통신 상태가 불안정해 TV화면이 자주 끊기는데, 네트워크 통신에서는 어떻게 아무 결함 없이 데이터가 전송될까? 이를 해결하는 단순하지만 강력한 방법, 체크섬(checksum)을 소개하려고 한다.</p><h2 id="Checksum이란"><a href="#Checksum이란" class="headerlink" title="Checksum이란"></a>Checksum이란</h2><p>체크섬은 <a href="https://ko.wikipedia.org/wiki/오류_검출_정정" target="_blank" rel="noopener">중복 검사</a>의 한 형태로, 수신한 자료의 무결성을 보장하려는 하나의 시도라 할 수 있다. 그 형태는 전송하려는 데이터를 더하여 얻은 값에 정해진 비트 수의 모듈라 연산을 취함으로서 결정되는 bit-string이며, 발신하는 입장에서는 raw-data에 checksum을 이어붙여 만들어진 새로운 데이터를 전송한다.</p><p><img src="/images/네트워크-통신에서의-데이터-무결성-검사-Checksum_Image.png" alt=""></p><p>위 그림을 보면 이해에 큰 도움이 될 것이다. Pre-code는 어떤 작업(실행)을 위해 필요한 필수 정보들이라 생각하면 되고, 실질적으로 해석해야 할 raw-data에 대해서 어떤 함수 f를 통해 생성되는 bit-string이 checksum이며, 이 파일의 꼬리에 checksum이 붙는 형태이다.</p><h2 id="Checksum의-동작"><a href="#Checksum의-동작" class="headerlink" title="Checksum의 동작"></a>Checksum의 동작</h2><p>크게 생성 함수 $f$에 대해서, 그리고 checksum을 통해 어떻게 무결성이 검증되는지 이 두 가지를 설명하려 한다. 방법만 보았을 땐 둘 다 굉장히 간단하다.</p><h4 id="Checksum의-생성"><a href="#Checksum의-생성" class="headerlink" title="Checksum의 생성"></a>Checksum의 생성</h4><p>흔히 나열된 데이터를 더하여 체크섬 숫자를 얻고, 이 숫자를 정해진 수로 나누어 그 나머지를 checksum으로 지정한다. 간단하게 예를 들어보겠다. 우리는 지금 32-bit(8-byte) 길이의 데이터에 대해 1-byte checksum을 생성하려고 한다. 32-bit data를 $m$이라 하고, 이 값은 $A267CBF3_{(16)}$이라 하자. 각 byte를 모두 더하면 $43_{(16)}$이 된다. 이때 checksum은 1-byte 크기이므로 $3_{(16)}$, 즉 $0011_{(2)}$이 될 것이다.</p><p>식으로 나타내면, $f(m) = c$ where $m = A267CBF3_{(16)}$, $c = 0011_{(2)}$</p><h4 id="무결성-검증"><a href="#무결성-검증" class="headerlink" title="무결성 검증"></a>무결성 검증</h4><p>수신한 메시지에서 raw-data와 checksum에 해당하는 bit-string을 각각  $m’$, $c’$이라 하자. 이때 checksum 생성 함수 $f$는 서로 약속되어 있다. 만약 $f(m’) = c’$이면, 메시지의 변조나 누락이 없다고 판단한다. 데이터의 변조는 크게 두 가지 케이스로 나뉜다.</p><ol><li>전송 과정에서 발생하는 물리적인 장애로 인한 변조</li><li>의도적인 데이터 조작</li></ol><p>여기까지 납득했다면 checksum은 1.의 대안으로 등장했다는 것을 알 수 있다. 2.의 경우 프로토콜의 암호화를 통해 극복한다. 이 이야기를 갑자기 한 이유는 단순하게 정의된 $f$에 대해 만들어진 $f(m’)$과 주어진 $c’$값의 비교 만으로 어떻게 무결성이 보장되는지 설명하기 위함이다.</p><p>$m’$은 어떤 이유로 인해 $m$(송신 raw-data)의 bit들이 변조된 bit-string이고, $c’$도 마찬가지의 이유로 변조되었을 가능성이 존재한다. 이 때 checksum이 1-bit라면 $m=m’$이 아닌데도 $f(m’)=c’$ 이 될 확률이 굉장히 높을 수 있다. 하지만, checksum의 bit를 하나 늘려 2-bit checksum으로 만들어버리면, 그 확률이 크게 감소한다. 구체적으로는, <strong>checksum bit가 2배로 늘어날 때마다 ‘$m \ne m’$이면서 $f(m’)=c’$일 확률’은 logarithmic하게 감소한다.</strong></p><p>Checksum 생성 함수 $f$의 특징을 고려하여 경우를 따져보면 쉽게 그 이유를 확인할 수 있는데, 글로만 보아선 크게 와닿지 않으므로 직접 간단한 테스트를 해보았다. (10000회)</p><table><thead><tr><th>Bits</th><th>2bit</th><th>4bit</th><th>8bit</th><th>16bit</th></tr></thead><tbody><tr><td>확률</td><td>0.252</td><td>0.0645</td><td>0.004</td><td>0.0</td></tr><tr><td></td><td>0.2471</td><td>0.0631</td><td>0.0033</td><td>0.0</td></tr><tr><td></td><td>0.2506</td><td>0.06</td><td>0.004</td><td>0.0</td></tr><tr><td></td><td>0.2487</td><td>0.0623</td><td>0.0038</td><td>0.0</td></tr><tr><td></td><td>0.2489</td><td>0.0677</td><td>0.0036</td><td>0.0001</td></tr><tr><td></td><td>0.2487</td><td>0.0624</td><td>0.0042</td><td>0.0</td></tr><tr><td></td><td>0.2521</td><td>0.0634</td><td>0.0041</td><td>0.0</td></tr><tr><td></td><td>0.2491</td><td>0.0641</td><td>0.0031</td><td>0.0</td></tr><tr><td></td><td>0.255</td><td>0.0625</td><td>0.0035</td><td>0.0</td></tr><tr><td></td><td>0.247</td><td>0.0655</td><td>0.0034</td><td>0.0</td></tr><tr><td>평균</td><td>0.2499</td><td>0.0636</td><td>0.0037</td><td>0.0</td></tr><tr><td>&asymp;</td><td></td><td>0.2499&sup2;</td><td>0.0636&sup2;</td><td></td></tr></tbody></table><p>0과 1로 이루어진 임의의 문장을 생성하고, 각 bit에 대해 동일하게 변조될 확률을 부여한다. 이를 통해 각 케이스 당 10번, 그리고 각 시도 당 10000번 $f(m’)=c’$여부를 확인하여 확률을 도출해냈다. Checksum bit를 2배로 늘려가며 같은 시행을 총 4번 반복하였고, 이를 통해 값들이 서로 지수적인 관계를 가진다는 것을 보이려했다.</p><p>2017학년도 1학기에 해보았던 것이라 구체적으로 설정했던 $m$의 length와 각 bit의 변조 확률은 기억나지 않는다. (아쉽게도 소스 코드를 폐기한듯..) 하지만 위 실험 결과로 미루어 보아 위에서 강조한 내용이 맞는 것을 확인할 수 있다..!</p><p><strong>즉, 어떤 메시지를 수신한 후, 그에 해당하는 $m’$과 $c’$에 대해 $f(m’)=c’$이 아닐경우 이를 reject하고 다시 같은 요청을 보내는데, 변조된 메시지가 이 과정을 통과할 가능성은 checksum의 길이에 따라 급격히 줄어드는 것이다.</strong></p><p>실제로 인터넷 통신 시스템이나 마이크로프로세서 시스템 내부 명령에서의 오류 검증에 checksum이 사용되며, 그 정확성은 확률로서 보장한다. 이런 간단한 방식으로 완전한 데이터 통신을 보장할 수 있다는 점이 실로 놀랍다! 관심있는 사람은 확률을 통해 정확성을 보장하는 비슷한 방식의 <a href="https://ko.wikipedia.org/wiki/영지식_증명" target="_blank" rel="noopener">영지식 증명 프로토콜(ZKP)</a>도 함께 살펴보면 좋을 것 같다.</p><hr><p><strong style="font-size:1.2em;">16-001 강래현</strong><br><strong class="nametag_bold">(Rae-Hyun Kang | Sharp)</strong><br>– Leader of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:krh000314@gmail.com" target="_blank" rel="noopener">krh000314@gmail.com</a></i>, <i class="icon fa fa-facebook" style="font-size: 1em;"> <a href="https://facebook.com/krh0314" target="_blank" rel="noopener">krh0314</a></i>, <i class="icon fa fa-github" style="font-size:1em;"> <a href="https://github.com/RHKang" target="_blank" rel="noopener">RHKang</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;네트워크 통신에서의 데이터 무결성 검사 ··· Checksum&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-001 Rae-Hyun Kang" scheme="http://eosofksa.github.io/categories/KSA-16/16-001-Rae-Hyun-Kang/"/>
    
    
      <category term="Network Communication" scheme="http://eosofksa.github.io/tags/Network-Communication/"/>
    
  </entry>
  
  <entry>
    <title>Github + Hexo 개발일지 下</title>
    <link href="http://eosofksa.github.io/2018/05/06/Github-Hexo-Devlog-2/"/>
    <id>http://eosofksa.github.io/2018/05/06/Github-Hexo-Devlog-2/</id>
    <published>2018-05-06T05:43:48.000Z</published>
    <updated>2018-05-12T14:16:32.077Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub + Hexo 개발일지 下 - 부가기능 추가 / 적용</p><a id="more"></a><h2 id="2018-05-06-2018-05-07"><a href="#2018-05-06-2018-05-07" class="headerlink" title="2018.05.06 ~ 2018.05.07"></a>2018.05.06 ~ 2018.05.07</h2><h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>사실 RSS 피드는 우리나라에서 그다지 활성화되어있지 않다. 새 글 알림을 RSS로 받아보는 사람을 주변에서 사실상 본 적이 없을 정도지만 대부분의 블로그에서 기본 기능으로 제공하는 것이기에 해놓아서 나쁠 것은 없다고 생각되어 구현하였다.<br>참고) [ <a href="https://juhojuho.github.io/2017/03/27/hexo-tip/" target="_blank" rel="noopener">https://juhojuho.github.io/2017/03/27/hexo-tip/</a> ]</p><h4 id="Markdown-MathJax"><a href="#Markdown-MathJax" class="headerlink" title="Markdown + MathJax"></a>Markdown + MathJax</h4><blockquote><p>개인적으로 앞서 두 글을 쓰면서 마크다운 문법이 상당히 편리함을 느끼고 있었으나, 위 블로그를 읽다보니 일부 뛰어난 실력을 가진 사용자들에게는 이것이 제한적일 수도 있다는 생각이 들었다. 더구나 일부는 전문적인 내용을 쓰려고 할텐데 그렇게 되면 마크다운이 받쳐주지 못하는 부분도 있을 것이기 때문에 지원해줄 수 있는 부분은 지원해주는 것이 나을 것 같았다. 근데 역시 익숙하지 않아선지 플러그인들의 사용법이 다 뭔가 너무 복잡한게 현실… 그래서 찾은 대안이 LaTeX 입력을 지원하는 MathJax다. LaTeX과 그리 거리가 멀지 않은 학생들이기에 그나마 간편하게 쓰지 않을까 싶지만 결국 다시 LaTeX으로 돌아오다니ㅜ</p></blockquote><p>라고 원래 쓰고 있었으나 이내 멍청함을 알았다. 기본적으로 Hueman 테마의 <code>_config.yml</code>에 mathjax 속성이 있었다. 그래서 그냥 True하면 되는 것이었다.<br>그래도 참고) [ <a href="https://www.npmjs.com/package/hexo-renderer-mathjax" target="_blank" rel="noopener">https://www.npmjs.com/package/hexo-renderer-mathjax</a> ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathbb&#123;ex.&#125;$ $^&#123;\forall&#125; x \in \mathbb&#123;N&#125;$, $\log x \geq 0$</span><br></pre></td></tr></table></figure></p><p>처럼 <span>$</span> 사이에 LaTeX 형식으로 수식을 쓰면 $\mathbb{ex.}$ $^{\forall} x \in \mathbb{N}$, $\log x \geq 0$ 처럼 나오게 된다. 수식 사이의 공백이나 텍스트는 LaTeX에서는 \text{abc}로 지원하긴 하지만 그냥 수식을 닫고 쓰는 게 훨씬 깔끔할 듯 하다.</p><h4 id="Google-Analytics-Search-Console-SEO"><a href="#Google-Analytics-Search-Console-SEO" class="headerlink" title="Google Analytics + Search Console, SEO"></a>Google Analytics + Search Console, SEO</h4><p>Hueman 테마의 <code>_config.yml</code>에는 기본적으로 google_analytics 속성이 있다. 방문자 수 기록도 하는 것이 좋을 거고 EOS 구글 계정도 있으니 해보기로 했다. 그런데 찾다보니 추가적으로 할 수 있는 기능들이 있길래 모두 적용해보았다.</p><blockquote><p>계속 리디렉션이 감지됨이라고 뜨는 것으로 보아 hexo에서 페이지를 처리할 때 기본적으로 리디렉션을 한 번은 거치는 듯 하다. 아마 바뀐 링크에 대해서 리디렉션을 정의해줄 수 있기에 정의가 되지 않은 경우는 셀프 리디렉션이 이루어지는 것으로 추측 중…</p></blockquote><p>위 현상의 원인을 찾았다. 페이지 URL을 입력할 때 http:// 로 입력을 하여 https:// 로 리디렉션되는 과정이 걸리는 것이었다.<br>참고) [ <a href="http://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/" target="_blank" rel="noopener">http://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/</a> ]</p><h5 id="2018-05-10"><a href="#2018-05-10" class="headerlink" title="~ 2018.05.10"></a>~ 2018.05.10</h5><p>페이지 내에 여러가지 추가할 수 있는 것이 많은데, 대표적인 것이 방문자 통계이다. 2018 SAF를 목표로 시작한 프로젝트기에 SAF 기간 동안의 최초 접속자 수를 기록하고자 설정하였다. 홍보 이전에 접속하는 사람들이 있을 수 있으나, 9:56AM 현재까진 없었다</p><p><img src="/images/Github-Hexo-DevLog-2-Google_analytics.png" alt="SAF 기간인 2018.05.10 ~ 2018.05.12 동안의 최초 방문일의 사용자를 기록한다."></p><p>이유를 찾지 못했으나 구글에 eosofksa.github.io를 검색하면 링크는 올바르게 나오나 제목이 [GitHub + Hexo 개발일지 下]라고 나온다. 한국 검색 결과에는 한글이 들어간 텍스트를 조합하여 구글이 알아서 추가한다는 얘기가 있는데, 이 이유에 해당하는 것 같아 페이지 제목을 [EOS]에서 [EOS of KSA | 한국과학영재학교의 컴퓨터 클럽]으로 변경하였다. 바로 적용되지는 않는 듯하다.<br>+) <a href="https://eosofksa.github.io/2018/05/09/Share-On-Kakaotalk/">카톡</a> 때문에 결국 제목을 [EOS 블로그]로 수정하였다. 2018.05.12 확인 결과 구글에서 메인 페이지의 제목은 [EOS 블로그]로 변경되었다!</p><h5 id="2018-05-12"><a href="#2018-05-12" class="headerlink" title="2018.05.12"></a>2018.05.12</h5><p>SAF 진행 중인 현재 신규 유입량이 기록되고 있는 것이 관측되어 참고용 데이터로의 가치가 충분할 것으로 예측된다.<br>뿐만 아니라 각 포스트별 순 페이지뷰 수가 기록되어 있는데, 기존에 2페이지에 있던 개발일지들이 SAF 기간동안 페이지뷰 수가 0인 것을 보고 충격을 받아 페이지 시스템을 없애버렸다. 사람들이 이 개발일지를 안 본 것은 절대로 재미없어보여서가 아니라 눈에 안 띄었기 때문일 것이다. 아무튼 그렇다. (ㅠㅜ)</p><h4 id="Open-Graph"><a href="#Open-Graph" class="headerlink" title="Open Graph"></a>Open Graph</h4><p>open_graph 속성에 대해 궁금해하던 중 다행히 위 블로그에서 이에 대한 내용을 다루었길래 참고하였다. 무엇인지와 어떻게 하는지에 대해서는 잘 정리된 아래 링크에서 알아보자. 이 블로그의 경우 <code>head.ejs</code>에서 <code>og:image</code>를 따로 제작한 이미지로 우회시키고, <code>og:title</code>에서 글 제목 뒤에 <code>“ | EOS”</code>가 붙도록 하였다.<br>참고) [ <a href="http://futurecreator.github.io/2016/06/16/opengraph-social-meta-tag/" target="_blank" rel="noopener">http://futurecreator.github.io/2016/06/16/opengraph-social-meta-tag/</a> ]</p><p><img src="/images/Github-Hexo-DevLog-2-OpenGraphImage.png" alt="카톡에서 되는 거 보고 신나서 야밤에 꺄륵거리는 중이다."></p><h4 id="Hexo-Markdown-Include"><a href="#Hexo-Markdown-Include" class="headerlink" title="Hexo-Markdown-Include"></a>Hexo-Markdown-Include</h4><h5 id="2018-05-08-4-00-AM"><a href="#2018-05-08-4-00-AM" class="headerlink" title="2018.05.08 4:00 AM"></a>2018.05.08 4:00 AM</h5><p>연휴의 마지막날 CPS 과제를 어찌어찌 마치고 룸메가 확통으로 고통받는 동안 글 아래에 들어가는 네임태그를 좀 편리하게 관리할 필요가 느껴져 MarkDown 안에 MarkDown을 포함하는 방법에 대하여 알아보게 되었다.<br>참고) [ <a href="https://stackoverflow.com/a/28617550" target="_blank" rel="noopener">https://stackoverflow.com/a/28617550</a> ]<br>markdown-include 모듈의 존재를 알게 되었으나 js 파일에 들어가야 하는데 hexo에서는 어디에 적합할지 모르겠어서 hexo용을 따로 찾아보니 다행히도 있더라. <code>_config.yml</code>을 수정하라는 게 테마 내의 것인지 hexo 전체의 것인지 구분되어있지 않아 헷갈렸으나 테마 내의 것을 수정하니 일단 성공했다.<br>dir 변수가 있으나, <code>sources/nametag</code>로 변수를 수정하고 해당 경로 내에 내 네임태그 파일을 넣었음에도 불구하고 <code>sources/_template</code> 안에 없다는 오류가 발생하는 것으로 보아 변수값을 바꾼다고 파일을 가져오는 대상 폴더가 바뀌지는 않는 듯 하다. 참조한 파일이 <code>sources/_template</code> 안에 없으면 방금 말한 그 오류가 발생하는데, 이 때문에 서버가 아예 켜지지 않기도 한다.<br>참고) [ <a href="https://www.npmjs.com/package/hexo-include-markdown" target="_blank" rel="noopener">https://www.npmjs.com/package/hexo-include-markdown</a> ]<br>+) 네임태그를 일괄적으로 수정할 수 있게 되었으니 아마 프로필 사진 등 좀 더 네임태그를 꾸미는 쪽의 수정작업을 진행해도 될 듯</p><h5 id="11-50-AM"><a href="#11-50-AM" class="headerlink" title="11:50 AM"></a>11:50 AM</h5><p> &lt;p>로 감싸서 파일 전체를 긁어오는 것으로 파악된다. 이 과정에서 파일 내의 줄바꿈을 모두 &lt;br/>로 변경하는 등의 작업이 일어나는데, 네임카드에 이미지를 넣는 부분은 article-entry img로 포함이 되는 바람에 좀 더 찾아봐야 될 듯<br> 그 와중에 &lt;p>와 &lt;br/>이 HTML에서 태그로 적용되는 바람에 이 부분만 다섯 번째 수정 중이다.(ㅠㅜ) 왼쪽을 &amp; lt;로 써주거나 오른쪽을 \&gt; 로 써야 하는 듯 한데, 첫번째는 너무 귀찮아 두번째를 택하였다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To print <span class="tag">&lt;<span class="name">p</span>&gt;</span>, you should write as <span class="tag">&lt;<span class="name">p\</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="video-js"><a href="#video-js" class="headerlink" title="video.js"></a>video.js</h4><h5 id="2018-05-10-1"><a href="#2018-05-10-1" class="headerlink" title="2018.05.10"></a>2018.05.10</h5><p><a href="https://eosofksa.github.io/2018/05/10/Game-made-by-game/">게임으로 만든 게임</a> 글을 업로드하던 중 비디오 플러그인이 갖춰져 있지 않다는 것을 알게 되었다. <a href="https://eosofksa.github.io/2018/05/09/Share-On-Kakaotalk/">카카오톡 공유 추가하기</a>를 하면서 script는 <code>head.ejs</code>에 추가하는 것이 맞다는 것을 깨달았기에 아래 링크를 참고하여 바로 설치했다.<br>참고) [ <a href="https://github.com/getpelican/pelican/issues/1099" target="_blank" rel="noopener">https://github.com/getpelican/pelican/issues/1099</a> ]</p><h4 id="Disqus-Comment-Count-Link"><a href="#Disqus-Comment-Count-Link" class="headerlink" title="Disqus Comment Count Link"></a>Disqus Comment Count Link</h4><h5 id="2018-05-12-1"><a href="#2018-05-12-1" class="headerlink" title="2018.05.12"></a>2018.05.12</h5><p><a href="https://eosofksa.github.io/2018/05/11/2018-SAF-Event/">2018 SAF 이벤트</a>를 진행하던 도중 댓글이 달렸는지 아닌지 확인할 길이 없다는 것을 깨닫고 뜨면 좋겠어서 했다.<br>참고) [ <a href="https://help.disqus.com/developer/adding-comment-count-links-to-your-home-page" target="_blank" rel="noopener">https://help.disqus.com/developer/adding-comment-count-links-to-your-home-page</a> ]<br>Hueman 테마의 경우 홈 화면의 제목 표시를 <code>themes/hueman/layout/common/post/title.ejs</code>에서 관리하고, 그 중에서도 linkable의 해당하는 경우이므로 아래와 같이 코드를 수정하였다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">typeof</span>(<span class="attr">linkable</span>) !== <span class="string">'undefined'</span> &amp;&amp; <span class="attr">linkable</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"&lt;%= class_name %&gt;"</span> <span class="attr">itemprop</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.path) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 추가 시작 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon fa fa-comments"</span> <span class="attr">style</span>=<span class="string">"font-size:0.7em; color:rgba(255,255,255,0.5)"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"disqus-comment-count"</span> <span class="attr">data-disqus-url</span>=<span class="string">"https://eosofksa.github.io&lt;%- url_for(post.path) %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 추가 끝 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><p><strong style="font-size:1.2em;">16-077 이원준</strong><br><strong class="nametag_bold">(Won-Joon Lee | sni/J)</strong><br>– 그림 그리는 개발자 / Designer and Web Designer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:wjl0316@naver.com" target="_blank" rel="noopener">wjl0316@naver.com</a></i>, <i class="icon fa fa-instagram" style="font-size:1em;"> <a href="https://instagr.am/sniperj_got_ya_back" target="_blank" rel="noopener">sniperj_got_ya_back</a></i>, <i class="icon fa fa-facebook" style="font-size: 1em;"> <a href="https://facebook.com/wonjoonlee0316" target="_blank" rel="noopener">WonJoonLee0316</a></i>, <i class="icon fa fa-github" style="font-size: 1em;"> <a href="https://github.com/sni-j" target="_blank" rel="noopener">sni-J</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub + Hexo 개발일지 下 - 부가기능 추가 / 적용&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-077 Won-Joon Lee" scheme="http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"/>
    
    
      <category term="DevLog" scheme="http://eosofksa.github.io/tags/DevLog/"/>
    
  </entry>
  
  <entry>
    <title>GitHub + Hexo 개발일지 中</title>
    <link href="http://eosofksa.github.io/2018/05/05/Github-Hexo-Devlog-1/"/>
    <id>http://eosofksa.github.io/2018/05/05/Github-Hexo-Devlog-1/</id>
    <published>2018-05-04T15:00:00.000Z</published>
    <updated>2018-05-07T19:45:25.204Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub + Hexo 개발일지 中 - 개발개발개발완성!</p><a id="more"></a><h2 id="2018-05-04-2018-05-05"><a href="#2018-05-04-2018-05-05" class="headerlink" title="2018.05.04 ~ 2018.05.05"></a>2018.05.04 ~ 2018.05.05</h2><h4 id="적용"><a href="#적용" class="headerlink" title="적용"></a>적용</h4><p>개발일지라고 하면 왠지 많은 사람들이 보고 따라할 수 있게 쓰는 것이 정석이겠지만, 나는 보고 따라한 사람이 나였기에 그냥 내가 뭘 보고 했는지를 기록하는 것이 좋을 것 같다.</p><ol><li><a href="https://kdydesign.github.io/2017/06/23/start-hexo-blog/" target="_blank" rel="noopener">https://kdydesign.github.io/2017/06/23/start-hexo-blog/</a><br>처음 Hexo를 발견한 블로그인데, 설명이 잘 되어 있어 감을 잡는 데에는 도움이 되었으나 전체적인 템포가 빨라 집중력이 흐트러지면 길을 잃는다.</li></ol><ol start="2"><li><a href="https://hyunseob.github.io/2016/02/23/start-hexo/" target="_blank" rel="noopener">https://hyunseob.github.io/2016/02/23/start-hexo/</a><br>나와 비슷한 케이스로 Hexo를 시작했기에 상당히 눈높이가 맞으리라 하고 시작했지만 시작부터 ‘아마 다 깔려있겠지만’을 보고 쫄아버렸다. 설명도 상당히 구체적이고 코드만 보고 해도 따라하기 쉬웠기에 추천한다.</li></ol><ol start="3"><li><a href="http://futurecreator.github.io/2016/06/14/get-started-with-hexo/" target="_blank" rel="noopener">http://futurecreator.github.io/2016/06/14/get-started-with-hexo/</a><br>위 두 사이트를 왔다갔다하던 도중 뭔가 새로운 자극이 필요하다 싶어서 찾은 페이지다. <code>_config.yml</code>에 들어가야 할 내용을 참고하기 아주 좋다. + Hueman 테마가 내 눈에 들어오기 시작했다.</li></ol><ol start="4"><li><a href="https://simhyejin.github.io/2016/06/24/hexo-themes/" target="_blank" rel="noopener">https://simhyejin.github.io/2016/06/24/hexo-themes/</a><br>Clexy 테마를 시도해보려 했는데 끝내 적용을 실패하고 방황하다가 테마 설치를 깔끔하게 설명해놓은 매력적인 로고를 가진 블로그의 포스트를 발견했다. 들어온 김에 댓글 기능을 위해서 계속 언급되던 Disqus도 적용해보고 Hueman 테마의 기본 설정도 마무리.</li></ol><ol start="5"><li><a href="https://gist.github.com/ihoneymon/652be052a0727ad59601" target="_blank" rel="noopener">https://gist.github.com/ihoneymon/652be052a0727ad59601</a><br>Markdown을 처음 보는 나의 당황스러움을 줄여준 고마운 페이지다. 개인적으로는 카XX께서 강요하다시피 추천한 L모 문법보다 훨씬 나은 것 같다고 생각하지만 숙제를 그걸로만 받겠다고 하시니….<br>추가로 Markdown에 관한 내용은 <a href="https://simhyejin.github.io/2016/06/30/Markdown-syntax/" target="_blank" rel="noopener">4번 블로그의 다른 글</a>에도 잘 나와 있다.</li></ol><p><img src="/images/Github-Hexo-DevLog-1-MarkDown_Example.png" alt="실습을 위해 이런 것도 했었다"></p><h4 id="테마-수정"><a href="#테마-수정" class="headerlink" title="테마 수정"></a>테마 수정</h4><p>이 부분부터는 디자인 감각을 영혼까지 끌어모아 적절한 색감을 찾기 위해 노력하였다. 물론 전적으로 내 취향인 테마로 꾸미긴 했지만 그래도 이걸 수정할 누군가가 색 테마 정도는 유지해줬으면 하는 작은 바람이다. 어떻게 보면 적용 부분에서 일한 양은 많지만 고생은 이 부분에서 더 한 것 같다. Hueman 테마가 잘 짜여진 것처럼 보이지만 <code>_variables.styl</code>에 정의된 색상이 있는데도 굳이 다시 HEX형태로 표현한 곳이 많아 모두 잡아내는 데에 난항을 겪었다. 특히 responsive를 위해 구성된 부분에서는 sidebar의 배경색이 사이즈별로 다 나뉘어 있어서 아직도 잡아내지 못한 사이즈가 있을지도 모른다.(ㅠㅜ)</p><p>어쨌든 이로써 2018년 5월 5일자로 사이트 구성을 완료하였다.</p><hr><p><strong style="font-size:1.2em;">16-077 이원준</strong><br><strong class="nametag_bold">(Won-Joon Lee | sni/J)</strong><br>– 그림 그리는 개발자 / Designer and Web Designer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:wjl0316@naver.com" target="_blank" rel="noopener">wjl0316@naver.com</a></i>, <i class="icon fa fa-instagram" style="font-size:1em;"> <a href="https://instagr.am/sniperj_got_ya_back" target="_blank" rel="noopener">sniperj_got_ya_back</a></i>, <i class="icon fa fa-facebook" style="font-size: 1em;"> <a href="https://facebook.com/wonjoonlee0316" target="_blank" rel="noopener">WonJoonLee0316</a></i>, <i class="icon fa fa-github" style="font-size: 1em;"> <a href="https://github.com/sni-j" target="_blank" rel="noopener">sni-J</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub + Hexo 개발일지 中 - 개발개발개발완성!&lt;/p&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-077 Won-Joon Lee" scheme="http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"/>
    
    
      <category term="DevLog" scheme="http://eosofksa.github.io/tags/DevLog/"/>
    
  </entry>
  
  <entry>
    <title>GitHub + Hexo 개발일지 上</title>
    <link href="http://eosofksa.github.io/2018/05/04/Github-Hexo-Devlog-0/"/>
    <id>http://eosofksa.github.io/2018/05/04/Github-Hexo-Devlog-0/</id>
    <published>2018-05-03T15:00:00.000Z</published>
    <updated>2018-05-07T19:45:30.058Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub + Hexo 개발일지 上 - 시작<br><a id="more"></a></p><h2 id="시작"><a href="#시작" class="headerlink" title="시작"></a>시작</h2><p>시작은 대입에 치여 시간을 내지 못하는 3학년들의 부스 활동을 위한 웹 매거진 제작이었다.<br>전시부인 우리 클럽의 특성상 SAF 때는 하는 것이 없기에 이번에는 SAF까지 해보자는 목표로<br>각자 컴퓨터와 관련된 관심분야에 관한 글을 써서 업로드하는 방향으로 진행하고자 하였다.</p><p>이 글들을 모아둘 웹 매거진을 제작할 플랫폼으로는</p><ul><li>페이스북 페이지</li><li>워드프레스</li><li>티스토리</li></ul><p>가 제시되었지만, 페이스북 페이지의 경우 홍보전 때 물밑이랑 이것저것 복잡하기도 하고,<br>워드프레스보다는 티스토리가 익숙해서 티스토리로 시작했다.<br>티스토리는 애초에 블로그 형식이기에 글의 작성과 편집이 기본적으로 제공되어 간편하고,<br>HTML과 CSS의 수정이 가능하다는 점으로 가볍게 하기에는 비교적 편리하였다.</p><h3 id="그-러-나"><a href="#그-러-나" class="headerlink" title="그.러.나."></a>그.러.나.</h3><p>HTML과 CSS’만’ 수정이 가능하기 때문에 티스토리에서 제공되는 테마 이외에는 적용하기가<br>어렵다는 단점이 있었고, 뭐 때마침 굳이 EOS 이름으로 GitHub 계정을 만들었다고 하기에<br>GitHub 페이지로 제작을 해보고자 하였다.</p><p>사실 처음엔 괜찮은 테마가 많아서 Jekyll을 하려고 했다. 근데 Ruby 기반이라 겁먹고 포기…<br>적절한 대안을 찾으려던 중 Hexo가 js 기반이라는 얘기를 보고 이거다 싶어서 시작했다.</p><hr><p><strong style="font-size:1.2em;">16-077 이원준</strong><br><strong class="nametag_bold">(Won-Joon Lee | sni/J)</strong><br>– 그림 그리는 개발자 / Designer and Web Designer of EOS 16<br><i class="icon fa fa-envelope" style="font-size:1em;"> <a href="mailto:wjl0316@naver.com" target="_blank" rel="noopener">wjl0316@naver.com</a></i>, <i class="icon fa fa-instagram" style="font-size:1em;"> <a href="https://instagr.am/sniperj_got_ya_back" target="_blank" rel="noopener">sniperj_got_ya_back</a></i>, <i class="icon fa fa-facebook" style="font-size: 1em;"> <a href="https://facebook.com/wonjoonlee0316" target="_blank" rel="noopener">WonJoonLee0316</a></i>, <i class="icon fa fa-github" style="font-size: 1em;"> <a href="https://github.com/sni-j" target="_blank" rel="noopener">sni-J</a></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub + Hexo 개발일지 上 - 시작&lt;br&gt;
    
    </summary>
    
      <category term="KSA 16" scheme="http://eosofksa.github.io/categories/KSA-16/"/>
    
      <category term="16-077 Won-Joon Lee" scheme="http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"/>
    
    
      <category term="DevLog" scheme="http://eosofksa.github.io/tags/DevLog/"/>
    
  </entry>
  
</feed>
