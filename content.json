{"meta":{"title":"EOS","subtitle":"Computer Club of KSA","description":"Web Magazine of EOS | 한국과학영재학교의 컴퓨터 클럽 EOS의 웹 매거진","author":"EOS (KSA 16-077 Won-Joon Lee)","url":"http://eosofksa.github.io"},"pages":[],"posts":[{"title":"게임으로 게임 만들기","slug":"Game-made-by-game","date":"2018-05-09T15:47:45.000Z","updated":"2018-05-09T16:07:20.309Z","comments":true,"path":"2018/05/10/Game-made-by-game/","link":"","permalink":"http://eosofksa.github.io/2018/05/10/Game-made-by-game/","excerpt":"게임으로 게임 만들기","text":"게임으로 게임 만들기 게임을 제작한다고 하면 제작도구로 흔히 게임메이커, 유니티, RPG maker, 그리고 좀 더 깊게는 Unreal Engine, Java 등을 상상할 것이다. 하지만 아주 소수의 특~별한 사람들은 1990년에 SNES(Super Nintendo Entertainment System, 한국에서는 슈퍼패미콤으로 알려져 있음)에 출시된 ‘슈퍼 마리오 월드’를 상상할 것이다. 게임을 플레이함으로써 또 하나의 게임을 코딩할 수 있다는 사실이 이상하게 들릴 수도 있지만, 이를 처음으로 해낸 스피드러너 Sethbling을 비롯해, 많은 게이머들이 게임을 만드는 데 성공하였다. 이들은 게임 속에서 발견할 수 있는 각종 버그를 활용하여, 게임을 해킹하거나 치트 코드 혹은 에뮬레이터를 사용하지 않고, 단순히 게임과 게임기 있는 그대로를 가지고 Snake, Pong, 그리고 Flappy Bird과 같은 클래식 게임들을 재현해내었다. 이러한 게임 제작은 어떻게 가능한 것인가? 과정을 일일이 설명하기엔 너무 복잡하고, 작성자가 그럴 시간도 없으니 간단하게 원리만 보이겠다. 위 사진에서 볼 수 있듯이, 게임 속 시스템에서의 모든 명령은 16진수 코드로 이루어진다. 스프라이트의 좌표에서부터 특정 값을 저장 및 불러오는 것, and, not 등의 연산자까지 다 16진수로 이루어진 값들을 읽어내어 게임을 플레이 할 수 있는 것이다. 이 중에 플레이어가 임의로 조작할 수 있는 값을 스프라이트들의 xy좌표가 있다. 위 화면에서의 예시와 같이, 슈퍼 마리오 월드는 한 화면에 대해 마리오를 제외하고는 총 12개의 스프라이트들(아이템, 요시, 적 포함)의 값까지만 처리한다. 지정 array의 각 스프라이트의 xy값들이 저장되며, 이러한 좌표값은 그 스프라이트를 가진 오브젝트가 사라진 이후에도 새로운 오브젝트가 나오지 않는 이상 저장된 상태를 유지한다. 이 array들이 플레이어가 게임을 통해 직접 값을 조정할 수 있다는 점을 통해 코드를 입력할 수 있는 것이다. 자 인제 값들을 넣었으니, 게임한테 이 값들이 스프라이트의 좌표값이 아닌 다른 코드라고 알려주기만 하면 된다!! 그걸 가능하게 하는 놈이 바로 이 놈이다. 요 놈의 이름은 Chargin Chuck으로, 적 캐릭터임에도 불구하고 아이템 클래스를 상속받고 있다. 쉽게 설명하자면, 게임이 얻을 수 있는 아이템으로 취급을 하고 있다는 것이다. 하지만 평소 게임플레이에서는 게임이 오브젝트가 아이템인지 판정하는 것보다 적인지 판정하는 것을 먼저 하기에 먹을 수 없다… 이를 해결하기 위해 요시를 이용해 버섯을 먹게 시킨 후, 바로 요시에서 내려 대신 버섯을 먹는다면, 요시로 하여금 그 위치에 대신 있는 Chuck을 먹게 할 수 있다!이렇게 되면, 게임은 Chuck을 먹었을 때 무슨 커멘드를 내려야 할지 모르기 때문에 default위치의 코드로 이동하게 된다. 근데 우연히도 이 위치가 바로 우리가 아까 변형한 아이템들의 스프라이트 위치들을 저장한 코드이다. 즉, 스프라이트 위치값들을 좌표값이 아닌 실행코드로 봄으로써 그 안에 플레이어가 코딩한 게임을 실행할 수 있게 되는 것이 바로 이 난잡한 게임메이커의 결론이다. 참고) 16-065 윤요한(Yo-Han Yoon | Johnny Youngster)– Music Producer of EOS 16 @gmail.com, , Johnny Youngster","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-065 Yo-Han Yoon","slug":"KSA-16/16-065-Yo-Han-Yoon","permalink":"http://eosofksa.github.io/categories/KSA-16/16-065-Yo-Han-Yoon/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://eosofksa.github.io/tags/Game/"}]},{"title":"Hexo 블로그에 카카오톡으로 공유 추가하기","slug":"Share-On-Kakaotalk","date":"2018-05-09T13:12:58.000Z","updated":"2018-05-09T15:27:03.836Z","comments":true,"path":"2018/05/09/Share-On-Kakaotalk/","link":"","permalink":"http://eosofksa.github.io/2018/05/09/Share-On-Kakaotalk/","excerpt":"상황은 이해가 가지만 참 힘들게 한다.","text":"상황은 이해가 가지만 참 힘들게 한다. 2018.05.09들어가기 전에…글의 기본 공유는 Twitter, Facebook, Pinterest, Google+ 총 4가지로 제공되어있다. 그러나 우리나라에서는 Pinterest나 Google+보다 카카오톡을 통한 공유가 더 활발히 이루어지고 있다. 이에 카카오톡 공유를 만들어보기로 하였다.보통 개발일지를 남길 때에는 개발을 쭈욱 하고 열었던 페이지들 중에 기록해 놓아야 할 링크들을 남기는 식으로 작성하는데, 이번엔 찾다찾다 못 찾아서 결국 혼자 한 부분도 있어 설명을 적어야 할 것 같다. (게다가 어떤 페이지를 열었는지도 기억이 안 난다.) 어쨌든 글이 두서 없을 수 있음을 미리 경고한다. EOS의 경우 이전에 더치페이 계산 카카오톡 봇을 만들기 위해 EOS 이름의 카카오 계정을 만든 적이 있어 이 계정으로 연결하였다. 그러나 정작 그 프로젝트는 흔적도 없이 소멸… 참고) [ http://prolite.tistory.com/1201 ] 카카오 쪽 처리가 매우 잘 정리되어 있다. 앞에서 혼자 다 한 것처럼 써놓긴 했지만 이 블로그가 반은 해준 것 같다. 위 블로그 글을 따라가다 보면 17번과 19번 사이에 번호가 안 매겨진 암묵적 18번이 있다. 그 부분이 문제가 되었는데, hexo 블로그는 기본적으로 .ejs로 구성되며 이 파일을 통해서 html과 js를 모두 생성하는 구조인데, 직접 넣어야 하는 이 상황은 EJS에 뉴비인 본인을 당황시키기에 충분했다. 1차 삽질이 문제를 해결하기 위한 본격적인 삽질에 앞서 themes/hueman 폴더 안의 파일들을 싹 다 뜯어보았다. (필요한 폴더/파일만 명시)1234567891011121314themes└── hueman └── layout ├── common │ ├── article.ejs │ └── head.ejs ├── _partial │ └── article.styl ├── share │ ├── index.ejs │ └── default.ejs └── source └── css └── _variables.styl default.ejs를 보면,1234567891011var html = [ '&lt;div id=\"' + id + '\" class=\"article-share-box\"&gt;', '&lt;input class=\"article-share-input\" value=\"' + url + '\"&gt;', '&lt;div class=\"article-share-links\"&gt;', '&lt;a href=\"https://twitter.com/intent/tweet?url=' + encodedUrl + '\" class=\"article-share-twitter\" target=\"_blank\" title=\"Twitter\"&gt;&lt;/a&gt;', '&lt;a href=\"https://www.facebook.com/sharer.php?u=' + encodedUrl + '\" class=\"article-share-facebook\" target=\"_blank\" title=\"Facebook\"&gt;&lt;/a&gt;', '&lt;a href=\"http://pinterest.com/pin/create/button/?url=' + encodedUrl + '\" class=\"article-share-pinterest\" target=\"_blank\" title=\"Pinterest\"&gt;&lt;/a&gt;', '&lt;a href=\"https://plus.google.com/share?url=' + encodedUrl + '\" class=\"article-share-google\" target=\"_blank\" title=\"Google+\"&gt;&lt;/a&gt;', '&lt;/div&gt;', '&lt;/div&gt;'].join(''); 을 발견할 수 있다. 그렇다면 카톡도 저런 링크를 찾으면 되겠다! 라는 희망을 품고 다른 대안을 찾기 위해 KakaoDevelopers_를 들어가 보았다. 그리고 절망을 보았다. https://developers.kakao.com/docs/js/kakaotalklink 카카오톡 공유 형태의 다양한 버전이 제시되어 있고 각각의 javascript 코드가 제시되어 있다. 역시나 저런 URL은 없었다. 뭐 어쨌든 코드를 보면 넣어줘야 하는 정보들이 많은 레이아웃이 있고 적은 레이아웃이 있다. 이 페이지의 경우 스크랩 템플릿이 가장 적합할 것으로 판단되어 이를 사용하기로 하였다. (절대로 요구하는 Argument의 수가 제일 적어서는 아니다) 일단 기본 상식 선에서 href에 javascript:sendLink(arg)의 형태로 처리하면 될지도 모른다는 판단이 섰다. 그러면 이제 문제가 되는 부분은 저 스크립트를 어디에 어떻게 넣어야 하는가이다. 이 때 구조 삽질이 빛을 발하는데, 최종적으로 생성되는 html의 글 부분은 article.ejs이 결정한다. 공유와 관련한 부분을 찾아보면123&lt;footer class=\"article-footer\"&gt; &lt;%- partial('share/index', &#123; post: post &#125;) %&gt;&lt;/footer&gt; 을 발견할 수 있다. 즉, share/index.ejs가 연결됨을 알 수 있다. 그래서 보면123&lt;% if (!theme.share || theme.share === 'default') &#123; %&gt; &lt;%- partial('default', &#123; post: post &#125;) %&gt;&lt;% &#125; %&gt; 부분만 쓸 만하다. Hexo 개발자가 대만인이다 보니 중국계열 SNS가 많은데 이 부분 처리를 위해 있는 것 같다. 아무튼 결국 다시 default.ejs로 돌아왔다. 정리하면 article.ejs안에 다 포함되어 있는건데, 그래서 &lt;%- partial(‘share/index’, { post: post }) %&gt; 앞에 넣었더니 안 된다. 왠지는 아직도 모르겠다. 해결해결책을 찾기 위해 기본으로 돌아가자는 마음으로 HTML을 처음 배울 적을 회상해봤다. 문득 머리를 스치는 한 가지 script는 왠만하면 head에 import하라 그래서 head.ejs로 갔다. 아래에 보니 js를 import하는 구간이 있다.12&lt;%- js('libs/jquery/2.0.3/jquery.min') %&gt;&lt;%- partial('plugin/scripts', &#123; isHead: true &#125;) %&gt; 신나서 넣었다. 됐다!+) 여담으로 중간에 뭘 잘못했는지 deploy 이후에 css가 깨지는 문제가 발생했다. 아마 붙여넣는 부분에서 뭔가를 잘라먹고 붙였던 것 같다. 한순간 멘탈이 X박살 났지만 부여잡고 롤백하고 차분하게 하나씩 했더니 됐다. 외관여하튼 그래서 저 default.ejs에1&apos;&lt;a href=&quot;javascript:sendLink(\\&apos;&apos; + url + &apos;\\&apos;)&quot; class=&quot;article-share-kakaotalk&quot; target=&quot;_blank&quot; title=&quot;Kakaotalk&quot;&gt;&lt;/a&gt;&apos; 를 추가해주었더니 article-share-kakaotalk이 없다.(;;;) 그래서 article-share-facebook를 찾아서 article.styl을 보니 비교적 구조가 단순하길래 복붙해서 하나 만들고 보니 아이콘이 애매했다. font-awesome 아이콘들은 대체로 fa-XXX로 표현되는데 \\f0XX형태라서 살짝 당황했지만 인터넷에 표를 찾아보니 금방 나오더라. 카톡 아이콘은 없기에 비슷한 말풍선 모양인 comment(\\f075)로 결정색은 color-XXX로 되어있길래 어디에 있나 했더니 _varaibles.styl에 있길래 카톡 아이콘 끌어다놓고 노란색 따서 color-kakaotalk을 만들었다. 노란색 해보니 안 카톡스러운 것 같아 갈색으로 바꿀까 생각 중… 참고)article.styl1234567.article-share-kakaotalk @extend $article-share-link &amp;:before content: \"\\f075\" &amp;:hover background: color-kakaotalk text-shadow: 0 1px darken(color-kakaotalk, 20%) _variables.styl12345color-twitter = #00acedcolor-facebook = #3b5998color-pinterest = #cb2027color-google = #dd4b39color-kakaotalk = #ffeb33 여담으로, 로컬서버에서 테스트하는 경우 카카오톡이 동작하지 않을 수 있다. 401에러가 발생하게 되는데 이는 카카오 서버에 등록한 URL과 다른 주소(127.0.0.1)에서 발생한 정보이기 때문에 Unauthorized로 판단하는 것이다. 16-077 이원준(Won-Joon Lee | sni/J)– Designer of EOS 16 wjl0316@naver.com, sniperj_got_ya_back, WonJoonLee0316, sni-J","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-077 Won-Joon Lee","slug":"KSA-16/16-077-Won-Joon-Lee","permalink":"http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"}],"tags":[{"name":"DevLog","slug":"DevLog","permalink":"http://eosofksa.github.io/tags/DevLog/"}]},{"title":"자동 정리 증명의 간단한 아이디어","slug":"Automatic-Theorem-Proving-Intro","date":"2018-05-09T12:52:00.000Z","updated":"2018-05-09T16:26:06.084Z","comments":true,"path":"2018/05/09/Automatic-Theorem-Proving-Intro/","link":"","permalink":"http://eosofksa.github.io/2018/05/09/Automatic-Theorem-Proving-Intro/","excerpt":"KSATP 연구회 부스도 많이 오세요","text":"KSATP 연구회 부스도 많이 오세요 Introduction자동정리증명은 자동으로 정리(Theorem)를 증명하는 알고리즘에 관한 문제이다. 어떠한 공리와 명제를 입력 받고 증명 시스템을 입력 받으면 증명 시스템을 이용하여 공리로부터 명제를 이끌어 내는 것이다. 이러한 것이 가능한 이유는 공리의 개수가 유한하고(개수가 무한히 많은 공리도 있으나 유한한 공리로 바꿀 수 있을 것이다) 증명 시스템 또한 유한하므로 이들을 잘 조합하면 알고리즘도 증명을 하는 것이 가능하다는 것을 알 수 있을 것이다. 자동정리증명은 세가지 부류로 나눌 수 있는데 일반적인 자동정리증명과 Human-readable, 그리고 Interactive가 있다. 일반적인 자동정리증명은 알고리즘이 자동으로 증명을 해주나 증명 과정을 사람이 보고 이해하는 것이 쉽지 않아 Provable을 판단하는 용도로 제한된다. Human-readable은 사람이 읽을 수 있는 증명 과정을 제공해주는데 이 과정이 복잡하여 효율이 떨어진다. Interactive Theorem Proving은 Proof Assistant라고도 불리는데 사람과 상호작용하여 자잘하고 증명하기 까다로운 Lemma는 자동정리증명이 증명을 해주고 전체적인 증명 흐름은 사람이 짜는 형태이다. 현재 수학 학회에서 널리 사용되는 자동증명검증 프로그램 Coq도 Interactive Theorem Proving이 가능하다. NP-Completeness자동정리증명은 유명한 NP-complete 문제 중 하나이다. 이를 확인하기 위해서는 자동정리증명이 NP이고 NP-hard인지 확인해야 하는데, NP-hard임은 SAT으로부터의 환원(reduction)을 쉽게 구성할 수 있으므로 자명하다. NP임을 보이는 방법은 여러가지가 있는데 정의에 입각하여 증명하는 편이 쉽다. 자동정리증명의 검증자(certifier) 알고리즘은 어떠한 정리와 증명을 입력받으면 알맞는 증명인지 확인하는 알고리즘일 것이다. 이 알고리즘은 다항 시간(poly-time)안에 가능함이 이미 증명되었고 Coq라는 유명한 프로그램도 있다. 따라서 자동정리증명은 NP-complete이고 이에 따라 사람들은 보통 자동정리증명의 다항시간 알고리즘을 찾지 않는다. First Order LogicFirst Order Logic(일차 논리)란, quantifier가 variable에만 허용되는 논리로 특정 언어를 지칭하는 것이 아니라 언어들의 성격에 따라 분류한 하나의 집합으로 생각해야 한다. 일차 논리 이외에도 이차 논리, 고차 논리도 있는데 이들은 relation과 function에도 quantifier가 붙는 것을 허용하는 논리다. 또 영차 논리도 있는데 영차 논리는 quantifier가 허용되지 않는 단순한 형태의 언어다. 이 문서에서 서술할 모든 논리학적 성질은 전부 일차 논리에 근거하여 작성할 것이다. 일차 논리인 특정한 언어는 두 가지로 나누어서 생각할 수 있는데 proof system과 syntax다. Syntax는 특정 언어가 다른 일차 논리와 다르게 이 언어에서만 사용되는 기호들을 의미한다. 예를 들어 덧셈의 + 기호는 집합에서 사용되지 않으므로 syntax라고 할 수 있다. 두번째로 proof system는 가장 중요하다고 할 수 있는데 Theory(어떠한 formula로 axiom과 같은 의미다. 이 문서에서는 Theorem과 Theory로 나누어서 사용하겠다.)로부터 Theorem을 이끌어내는 추론 방식이다. 유명한 proof system에는 Hilbert style과 Natural Deduction(Sequent Calculus)등이 있는데 우리가 일반적으로 알고 있는 proof system이 Natural Deduction이므로 이 문서에서는 Natural Deduction을 가정하고 작성하겠다. 이제 일차 논리의 성질들에 대해서 알아보자.We said $\\mathcal{L}$-theory $\\mathcal{T}$ is consistent, $Con(\\mathcal{T})$, if there is no $A \\in \\mathcal{L} _ {S}$ s.t. $\\mathcal{T} \\vdash A$ and $\\mathcal{T} \\vdash \\neg A$.Also, we said $\\mathcal{L}$-theory $\\mathcal{T}$ is complete if for $^{\\forall} A\\ \\in \\mathcal{L}_{S}$, $\\mathcal{T} \\vdash A$ or $\\mathcal{T} \\vdash \\neg A$, but not both. 즉 어떤 Theory $\\mathcal{T}$가 complete하면 consistent를 만족하는 것이다.그런데 괴델의 불완전성 정리에 의하면 모든 일차 논리의 Theory는 complete하지 않는다.즉, 항상 Theory와 independent한, 증명불가능인, Theorem이 존재한다는 것이다.그래서 일반적으로 자동정리증명 프로그램은 증명 불가능한 명제를 고려하지 않는다.증명불가능의 예시를 보기 위해 ZFC에 대해 알아보자. ZFCZFC(Zermelo–Fraenkel with axiom of choice)는 가장 유명한 집합 공리계로 유한한 공리계의 대표 예시라고 할 수 있다. ZFC에는 확장 공리(axiom of extensionality), 정칙성 공리(axiom of regularity), 짝 공리(axiom of pairing), 합집합 공리(axiom of union), 멱집합 공리(axiom of power set), 무한 공리(axiom of infinity), 분류 공리꼴(axiom schema of specification), 치환 공리꼴(axiom schema of replacement), 그리고 선택 공리(axiom of choice)로 이루어져있다. 사실 집합 공리의 경우 간단하게 표현이 가능하지 않을까라고 생각하기 쉽지만 Russel의 패러독스를 보면 생각이 바뀔 것이다. 이렇게 수학자들이 고심하여 열심히 만든 공리계 ZFC조차 증명 불가능한 Theorem들이 있는데 대표적인 예시가 연속체 가설(continuum hypothesis)이다. 이 문제는 자연수 집합의 크기와 실수 집합의 크기 사이의 크기를 가지는 무한 집합이 존재하는 가에 대한 문제로(또는 $2^{\\aleph_0}=\\aleph_1$으로 이해할 수도 있다.) 증명불가능이 증명되었다. 만약 이 글을 읽고 자동정리증명에 흥미가 생겼다면 이번 SAF의 KSATP 부스에서 더 자세한 설명을 들을 수 있다. 16-010 김기환(Ki-Hwan Kim | atheNa)– Follower of Blizzard corp. (EOS 16) jerry010222@naver.com","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-010 Ki-Hwan Kim","slug":"KSA-16/16-010-Ki-Hwan-Kim","permalink":"http://eosofksa.github.io/categories/KSA-16/16-010-Ki-Hwan-Kim/"}],"tags":[{"name":"Automatic Theorem Proving","slug":"Automatic-Theorem-Proving","permalink":"http://eosofksa.github.io/tags/Automatic-Theorem-Proving/"}]},{"title":"게임 잡학 퀴즈","slug":"Game-quizzes","date":"2018-05-09T11:06:00.000Z","updated":"2018-05-09T15:43:56.528Z","comments":true,"path":"2018/05/09/Game-quizzes/","link":"","permalink":"http://eosofksa.github.io/2018/05/09/Game-quizzes/","excerpt":"게임 잡학 퀴즈!","text":"게임 잡학 퀴즈! Q1: 다음 중 가장 많은 수익을 올린 게임 IP(Information Property; 지적 재삭권)은 무엇일까? (1) 테트리스 (2) 슈퍼마리오 (3) 마인크래프트 (4) 히어로즈 오브 더 스톰 (5) 히어로즈 오브 더 스톰 (6) 히어로즈 오브 더 스톰 Q2: 테트리스 제작자 알렉세이 파지트노프가 1984년에 테트리스 제작 이후 10년동안 번 돈은 얼마 정도가 될까? (1) 10만 달러 이상 (2) 1만 달러 이상 10만 달러 이하 (3) 100 달러 이상 1만 달러 이하 (4) 100 달러 이하 Q3: 다음 중 현재 진행되고 있는 시리즈 중 가장 오래된 게임 시리즈는? (1) 갤러그 (2) 스페이스 인베이더 (3) 슈퍼 마리오 (4) 스타크래프트 Q4: 다음 중 가장 처음으로 디자인된 포켓몬은? (1) 피카츄 (2) 푸린 (3) 이상해씨 (4) 코뿌리 Q5: 다음 중 실사 영화화가 되지 않은 게임 시리즈는? (1) 슈퍼 마리오 브라더스 (2) 스트리트 파이터 (3) 레지덴트 이빌 (4) 포켓몬스터 Q6: 다음 중 게임 시장에 게임 국제 ESRB(나이 제한제)를 처음 도입하게 한 게임은? (1) 모탈 컴뱃 (2) 레지던트 이블 (3) GTA (4) 슈퍼 메트로이드 Q7: 카즈미 토타카는 1990년부터 현재까지 닌텐도의 수많은 게임들의 음향 감독을 맡아왔다. 그가 감독한 게임은 ‘토타카의 테마’라는 곡이 게임 어딘가에 숨겨져 있는 것으로 유명하다. 다음의 토타카가 음향 감독을 맡은 게임들 중 ‘토타카의 테마’가 수록되지 않은 게임은? (1) 요시 아일랜드 (2) 대난투 스매시 브라더스 X (3) 위 스포츠 (4) 놀러오세요 동물의 숲 Q8: 다음 중 GOTY(Game of The Year) 후보에 든 적이 한번도 없는 게임은? (1) 다크 소울 2 (2) 소닉 붐 (3) 하스스톤 (4) 페르소나 5 Q9: 다음 중 스트리밍 서비스로 유명한 트위치에서 스트리밍 금지 목록에 수록된 게임은? (1) 얀데레 시뮬레이터 (2) GTA 5 (3) 단간론파 V3 (4) 갓 오브 워: 어센션 Q10: 게임사의 가장 유명하고 널리 알려진 캐릭터인 마리오는 여러 게임들에 걸쳐 다양한 직종에 종사하는 모습을 보였다. 올림픽 선수에서부터 까지 다양한 일을 해온 마리오가 다음의 직업들 중 게임에서 하는 모습을 보인 적이 없는 것은? (1) 베트남 전쟁의 군인 (2) 복싱 심판 (3) 배관공 (4) 의사 Q11. 2014년 Carrie Swidecki는 138시간 34초동안 쉬지 않고 ‘이 게임’을 플레이 함으로써 기네스북 기록을 달성하였다. ‘이 게임’은? (1) 팀 포트리스 2 (2) 캔디 크러시 (3) 월드 오브 워크래프트 (4) Just Dance 16-065 윤요한(Yo-Han Yoon | Johnny Youngster)– Music Producer of EOS 16 @gmail.com, , Johnny Youngster","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-065 Yo-Han Yoon","slug":"KSA-16/16-065-Yo-Han-Yoon","permalink":"http://eosofksa.github.io/categories/KSA-16/16-065-Yo-Han-Yoon/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://eosofksa.github.io/tags/Game/"}]},{"title":"네트워크 통신에서의 데이터 무결성 검사","slug":"네트워크-통신에서의-데이터-무결성-검사","date":"2018-05-08T04:47:33.000Z","updated":"2018-05-09T15:33:29.818Z","comments":true,"path":"2018/05/08/네트워크-통신에서의-데이터-무결성-검사/","link":"","permalink":"http://eosofksa.github.io/2018/05/08/네트워크-통신에서의-데이터-무결성-검사/","excerpt":"네트워크 통신에서의 데이터 무결성 검사 ··· Checksum","text":"네트워크 통신에서의 데이터 무결성 검사 ··· Checksum INTRO누구나 컴퓨터는 0과 1로 이루어져 있다는 이야기를 들어본 적이 있을 것이다. 실제로 모든 디지털 정보는 0과 1의 조합을 통해 표현된다. 우리가 어떤 문자를 이용해 정보를 기록하는 것과 같은 이치로 볼 수 있는데, 그 이해를 위해 두 가지 간단한 예를 들어보겠다. 먼저, 사람이 사용하는 문장을 0과 1로 바꾸어보자. 만약 a부터 e까지 다섯 개의 알파벳을 a: 000 / b: 001 / c: 01 / d: 10 / e: 11 와 같이 대응시킨다면, ‘abbdca’라는 문장은 ‘0000010011001000’로, 거꾸로 ‘0000010011001000’라는 문장은 위 대응 관계에 근거하여 ‘abbdca’로 유일하게 해석됨을 직접 확인할 수 있다. 이번에는 어떤 명령들을 0과 1로 나타내보자. 4가지 명령 ‘앉아’, ‘일어서’, ‘왼손’, ‘오른손’을 최대한 짧은 길이의 문장으로 겹치지 않게 표현하기 위해선 최소 4가지의 경우를 나타낼 수 있는 0과 1의 조합을 생각해야한다. 이 경우에는 2-bit 만을 이용하여 00, 01, 10, 11 네 가지 경우를 각 명령에 대응 시킬 수 있으며, 해석하는 입장에서는 각 bit의 값을 보고 즉각 어떤 명령인지 알 수 있을 것이다. 우리가 매일 사용하는 전자기기들은 매 순간 이러한 문장들을 저장하고, 컴퓨터의 중추 CPU에서는 0과 1로 표현된 정해진 길이의 명령들을 1초에 수억번에서 수십억번 가까이 처리하고 있다. 특히 전자기기가 일반인들에게 널리 보급되고, 모든 분야에서 컴퓨터가 사용되고 있으며, 네트워크가 상상할 수 없는 규모로 확장된 지금 사회에선 매 순간 엄청난 양의 정보들이 이동하고 있다. 여기서 한 가지 의문이 든다. 0과 1로만 이루어진 정보를 무선 통신으로 주고 받는데, 우리의 스마트폰과 노트북은 지구 반대편에서 보낸 정보 조차 한치의 오차 없이 받아낸다. 데이터의 결함은 그 규모에 상관 없이 큰 골칫거리인게, 위에서 예로 든 ‘0000010011001000’를 전송하는 도중 통신의 장애로 인해 ‘0000000011001000’으로 받아진다면 그 의미는 ‘abbdca’가 아닌 ‘aabdca’로 완전히 다른 뜻이 되어버린다. 전송하는 문장이 어떤 명령이라면 시스템 자체에 결함이 생기는 것이다. 하지만 당장 비가 오는 날 축구 생중계를 볼 때만 해도 통신 상태가 불안정해 TV화면이 자주 끊기는데, 네트워크 통신에서는 어떻게 아무 결함 없이 데이터가 전송될까? 이를 해결하는 단순하지만 강력한 방법, 체크섬(checksum)을 소개하려고 한다. Checksum이란체크섬은 중복 검사의 한 형태로, 수신한 자료의 무결성을 보장하려는 하나의 시도라 할 수 있다. 그 형태는 전송하려는 데이터를 더하여 얻은 값에 정해진 비트 수의 모듈라 연산을 취함으로서 결정되는 bit-string이며, 발신하는 입장에서는 raw-data에 checksum을 이어붙여 만들어진 새로운 데이터를 전송한다. 위 그림을 보면 이해에 큰 도움이 될 것이다. Pre-code는 어떤 작업(실행)을 위해 필요한 필수 정보들이라 생각하면 되고, 실질적으로 해석해야 할 raw-data에 대해서 어떤 함수 f를 통해 생성되는 bit-string이 checksum이며, 이 파일의 꼬리에 checksum이 붙는 형태이다. Checksum의 동작크게 생성 함수 $f$에 대해서, 그리고 checksum을 통해 어떻게 무결성이 검증되는지 이 두 가지를 설명하려 한다. 방법만 보았을 땐 둘 다 굉장히 간단하다. Checksum의 생성흔히 나열된 데이터를 더하여 체크섬 숫자를 얻고, 이 숫자를 정해진 수로 나누어 그 나머지를 checksum으로 지정한다. 간단하게 예를 들어보겠다. 우리는 지금 32-bit(8-byte) 길이의 데이터에 대해 1-byte checksum을 생성하려고 한다. 32-bit data를 $m$이라 하고, 이 값은 $A267CBF3_{(16)}$이라 하자. 각 byte를 모두 더하면 $43_{(16)}$이 된다. 이때 checksum은 1-byte 크기이므로 $3_{(16)}$, 즉 $0011_{(2)}$이 될 것이다. 식으로 나타내면, $f(m) = c$ where $m = A267CBF3_{(16)}$, $c = 0011_{(2)}$ 무결성 검증수신한 메시지에서 raw-data와 checksum에 해당하는 bit-string을 각각 $m’$, $c’$이라 하자. 이때 checksum 생성 함수 $f$는 서로 약속되어 있다. 만약 $f(m’) = c’$이면, 메시지의 변조나 누락이 없다고 판단한다. 데이터의 변조는 크게 두 가지 케이스로 나뉜다. 전송 과정에서 발생하는 물리적인 장애로 인한 변조 의도적인 데이터 조작 여기까지 납득했다면 checksum은 1.의 대안으로 등장했다는 것을 알 수 있다. 2.의 경우 프로토콜의 암호화를 통해 극복한다. 이 이야기를 갑자기 한 이유는 단순하게 정의된 $f$에 대해 만들어진 $f(m’)$과 주어진 $c’$값의 비교 만으로 어떻게 무결성이 보장되는지 설명하기 위함이다. $m’$은 어떤 이유로 인해 $m$(송신 raw-data)의 bit들이 변조된 bit-string이고, $c’$도 마찬가지의 이유로 변조되었을 가능성이 존재한다. 이 때 checksum이 1-bit라면 $m=m’$이 아닌데도 $f(m’)=c’$ 이 될 확률이 굉장히 높을 수 있다. 하지만, checksum의 bit를 하나 늘려 2-bit checksum으로 만들어버리면, 그 확률이 크게 감소한다. 구체적으로는, checksum bit가 2배로 늘어날 때마다 ‘$m \\ne m’$이면서 $f(m’)=c’$일 확률’은 logarithmic하게 감소한다. Checksum 생성 함수 $f$의 특징을 고려하여 경우를 따져보면 쉽게 그 이유를 확인할 수 있는데, 글로만 보아선 크게 와닿지 않으므로 직접 간단한 테스트를 해보았다. (10000회) Bits 2bit 4bit 8bit 16bit 확률 0.252 0.0645 0.004 0.0 0.2471 0.0631 0.0033 0.0 0.2506 0.06 0.004 0.0 0.2487 0.0623 0.0038 0.0 0.2489 0.0677 0.0036 0.0001 0.2487 0.0624 0.0042 0.0 0.2521 0.0634 0.0041 0.0 0.2491 0.0641 0.0031 0.0 0.255 0.0625 0.0035 0.0 0.247 0.0655 0.0034 0.0 평균 0.2499 0.0636 0.0037 0.0 &asymp; 0.2499&sup2; 0.0636&sup2; 0과 1로 이루어진 임의의 문장을 생성하고, 각 bit에 대해 동일하게 변조될 확률을 부여한다. 이를 통해 각 케이스 당 10번, 그리고 각 시도 당 10000번 $f(m’)=c’$여부를 확인하여 확률을 도출해냈다. Checksum bit를 2배로 늘려가며 같은 시행을 총 4번 반복하였고, 이를 통해 값들이 서로 지수적인 관계를 가진다는 것을 보이려했다. 2017학년도 1학기에 해보았던 것이라 구체적으로 설정했던 $m$의 length와 각 bit의 변조 확률은 기억나지 않는다. (아쉽게도 소스 코드를 폐기한듯..) 하지만 위 실험 결과로 미루어 보아 위에서 강조한 내용이 맞는 것을 확인할 수 있다..! 즉, 어떤 메시지를 수신한 후, 그에 해당하는 $m’$과 $c’$에 대해 $f(m’)=c’$이 아닐경우 이를 reject하고 다시 같은 요청을 보내는데, 변조된 메시지가 이 과정을 통과할 가능성은 checksum의 길이에 따라 급격히 줄어드는 것이다. 실제로 인터넷 통신 시스템이나 마이크로프로세서 시스템 내부 명령에서의 오류 검증에 checksum이 사용되며, 그 정확성은 확률로서 보장한다. 이런 간단한 방식으로 완전한 데이터 통신을 보장할 수 있다는 점이 실로 놀랍다! 관심있는 사람은 확률을 통해 정확성을 보장하는 비슷한 방식의 영지식 증명 프로토콜(ZKP)도 함께 살펴보면 좋을 것 같다. 16-001 강래현(Rae-Hyun Kang | Sharp)– Leader of EOS 16 krh000314@gmail.com, krh0314, RHKang","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-001 Rae-Hyun Kang","slug":"KSA-16/16-001-Rae-Hyun-Kang","permalink":"http://eosofksa.github.io/categories/KSA-16/16-001-Rae-Hyun-Kang/"}],"tags":[{"name":"Network Communication","slug":"Network-Communication","permalink":"http://eosofksa.github.io/tags/Network-Communication/"}]},{"title":"Github + Hexo 개발일지 下","slug":"Github-Hexo-Devlog-2","date":"2018-05-06T05:43:48.000Z","updated":"2018-05-09T16:07:06.701Z","comments":true,"path":"2018/05/06/Github-Hexo-Devlog-2/","link":"","permalink":"http://eosofksa.github.io/2018/05/06/Github-Hexo-Devlog-2/","excerpt":"GitHub + Hexo 개발일지 下 - 부가기능 추가 / 적용","text":"GitHub + Hexo 개발일지 下 - 부가기능 추가 / 적용 2018.05.06 ~ 2018.05.07RSS사실 RSS 피드는 우리나라에서 그다지 활성화되어있지 않다. 새 글 알림을 RSS로 받아보는 사람을 주변에서 사실상 본 적이 없을 정도지만 대부분의 블로그에서 기본 기능으로 제공하는 것이기에 해놓아서 나쁠 것은 없다고 생각되어 구현하였다.참고) [ https://juhojuho.github.io/2017/03/27/hexo-tip/ ] Markdown + MathJax 개인적으로 앞서 두 글을 쓰면서 마크다운 문법이 상당히 편리함을 느끼고 있었으나, 위 블로그를 읽다보니 일부 뛰어난 실력을 가진 사용자들에게는 이것이 제한적일 수도 있다는 생각이 들었다. 더구나 일부는 전문적인 내용을 쓰려고 할텐데 그렇게 되면 마크다운이 받쳐주지 못하는 부분도 있을 것이기 때문에 지원해줄 수 있는 부분은 지원해주는 것이 나을 것 같았다. 근데 역시 익숙하지 않아선지 플러그인들의 사용법이 다 뭔가 너무 복잡한게 현실… 그래서 찾은 대안이 LaTeX 입력을 지원하는 MathJax다. LaTeX과 그리 거리가 멀지 않은 학생들이기에 그나마 간편하게 쓰지 않을까 싶지만 결국 다시 LaTeX으로 돌아오다니ㅜ 라고 원래 쓰고 있었으나 이내 멍청함을 알았다. 기본적으로 Hueman 테마의 _config.yml에 mathjax 속성이 있었다. 그래서 그냥 True하면 되는 것이었다.그래도 참고) [ https://www.npmjs.com/package/hexo-renderer-mathjax ]1$\\mathbb&#123;ex.&#125;$ $^&#123;\\forall&#125; x \\in \\mathbb&#123;N&#125;$, $\\log x \\geq 0$ 처럼 $ 사이에 LaTeX 형식으로 수식을 쓰면 $\\mathbb{ex.}$ $^{\\forall} x \\in \\mathbb{N}$, $\\log x \\geq 0$ 처럼 나오게 된다. 수식 사이의 공백이나 텍스트는 LaTeX에서는 \\text{abc}로 지원하긴 하지만 그냥 수식을 닫고 쓰는 게 훨씬 깔끔할 듯 하다. Google Analytics + Search Console, SEOHueman 테마의 _config.yml에는 기본적으로 google_analytics 속성이 있다. 방문자 수 기록도 하는 것이 좋을 거고 EOS 구글 계정도 있으니 해보기로 했다. 그런데 찾다보니 추가적으로 할 수 있는 기능들이 있길래 모두 적용해보았다. 계속 리디렉션이 감지됨이라고 뜨는 것으로 보아 hexo에서 페이지를 처리할 때 기본적으로 리디렉션을 한 번은 거치는 듯 하다. 아마 바뀐 링크에 대해서 리디렉션을 정의해줄 수 있기에 정의가 되지 않은 경우는 셀프 리디렉션이 이루어지는 것으로 추측 중… 위 현상의 원인을 찾았다. 페이지 URL을 입력할 때 http:// 로 입력을 하여 https:// 로 리디렉션되는 과정이 걸리는 것이었다.참고) [ http://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/ ] Open Graphopen_graph 속성에 대해 궁금해하던 중 다행히 위 블로그에서 이에 대한 내용을 다루었길래 참고하였다. 무엇인지와 어떻게 하는지에 대해서는 잘 정리된 아래 링크에서 알아보자. 이 블로그의 경우 head.ejs에서 og:image를 따로 제작한 이미지로 우회시키고, og:title에서 글 제목 뒤에 “ | EOS”가 붙도록 하였다.참고) [ http://futurecreator.github.io/2016/06/16/opengraph-social-meta-tag/ ] 2018.05.08 4:00 AMHexo-Markdown-Include연휴의 마지막날 CPS 과제를 어찌어찌 마치고 룸메가 확통으로 고통받는 동안 글 아래에 들어가는 네임태그를 좀 편리하게 관리할 필요가 느껴져 MarkDown 안에 MarkDown을 포함하는 방법에 대하여 알아보게 되었다.참고) [ https://stackoverflow.com/a/28617550 ]markdown-include 모듈의 존재를 알게 되었으나 js 파일에 들어가야 하는데 hexo에서는 어디에 적합할지 모르겠어서 hexo용을 따로 찾아보니 다행히도 있더라. _config.yml을 수정하라는 게 테마 내의 것인지 hexo 전체의 것인지 구분되어있지 않아 헷갈렸으나 테마 내의 것을 수정하니 일단 성공했다.dir 변수가 있으나, sources/nametag로 변수를 수정하고 해당 경로 내에 내 네임태그 파일을 넣었음에도 불구하고 sources/_template 안에 없다는 오류가 발생하는 것으로 보아 변수값을 바꾼다고 파일을 가져오는 대상 폴더가 바뀌지는 않는 듯 하다. 참조한 파일이 sources/_template 안에 없으면 방금 말한 그 오류가 발생하는데, 이 때문에 서버가 아예 켜지지 않기도 한다.참고) [ https://www.npmjs.com/package/hexo-include-markdown ]+) 네임태그를 일괄적으로 수정할 수 있게 되었으니 아마 프로필 사진 등 좀 더 네임태그를 꾸미는 쪽의 수정작업을 진행해도 될 듯 11:50 AM &lt;p>로 감싸서 파일 전체를 긁어오는 것으로 파악된다. 이 과정에서 파일 내의 줄바꿈을 모두 &lt;br/>로 변경하는 등의 작업이 일어나는데, 네임카드에 이미지를 넣는 부분은 article-entry img로 포함이 되는 바람에 좀 더 찾아봐야 될 듯 그 와중에 &lt;p>와 &lt;br/>이 HTML에서 태그로 적용되는 바람에 이 부분만 다섯 번째 수정 중이다.(ㅠㅜ) 왼쪽을 &amp; lt;로 써주거나 오른쪽을 \\&gt; 로 써야 하는 듯 한데, 첫번째는 너무 귀찮아 두번째를 택하였다.1To print &lt;p&gt;, you should write as &lt;p\\&gt; ##2018.05.10 video.js게임으로 만든 게임 글을 업로드하던 중 비디오 플러그인이 갖춰져 있지 않다는 것을 알게 되었다. 카카오톡 공유 추가하기를 하면서 script는 head.ejs에 추가하는 것이 맞다는 것을 깨달았기에 아래 링크를 참고하여 바로 설치했다.참고) [ https://github.com/getpelican/pelican/issues/1099 ] 16-077 이원준(Won-Joon Lee | sni/J)– Designer of EOS 16 wjl0316@naver.com, sniperj_got_ya_back, WonJoonLee0316, sni-J","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-077 Won-Joon Lee","slug":"KSA-16/16-077-Won-Joon-Lee","permalink":"http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"}],"tags":[{"name":"DevLog","slug":"DevLog","permalink":"http://eosofksa.github.io/tags/DevLog/"}]},{"title":"GitHub + Hexo 개발일지 中","slug":"Github-Hexo-Devlog-1","date":"2018-05-04T15:00:00.000Z","updated":"2018-05-07T19:45:25.204Z","comments":true,"path":"2018/05/05/Github-Hexo-Devlog-1/","link":"","permalink":"http://eosofksa.github.io/2018/05/05/Github-Hexo-Devlog-1/","excerpt":"GitHub + Hexo 개발일지 中 - 개발개발개발완성!","text":"GitHub + Hexo 개발일지 中 - 개발개발개발완성! 2018.05.04 ~ 2018.05.05적용개발일지라고 하면 왠지 많은 사람들이 보고 따라할 수 있게 쓰는 것이 정석이겠지만, 나는 보고 따라한 사람이 나였기에 그냥 내가 뭘 보고 했는지를 기록하는 것이 좋을 것 같다. https://kdydesign.github.io/2017/06/23/start-hexo-blog/처음 Hexo를 발견한 블로그인데, 설명이 잘 되어 있어 감을 잡는 데에는 도움이 되었으나 전체적인 템포가 빨라 집중력이 흐트러지면 길을 잃는다. https://hyunseob.github.io/2016/02/23/start-hexo/나와 비슷한 케이스로 Hexo를 시작했기에 상당히 눈높이가 맞으리라 하고 시작했지만 시작부터 ‘아마 다 깔려있겠지만’을 보고 쫄아버렸다. 설명도 상당히 구체적이고 코드만 보고 해도 따라하기 쉬웠기에 추천한다. http://futurecreator.github.io/2016/06/14/get-started-with-hexo/위 두 사이트를 왔다갔다하던 도중 뭔가 새로운 자극이 필요하다 싶어서 찾은 페이지다. _config.yml에 들어가야 할 내용을 참고하기 아주 좋다. + Hueman 테마가 내 눈에 들어오기 시작했다. https://simhyejin.github.io/2016/06/24/hexo-themes/Clexy 테마를 시도해보려 했는데 끝내 적용을 실패하고 방황하다가 테마 설치를 깔끔하게 설명해놓은 매력적인 로고를 가진 블로그의 포스트를 발견했다. 들어온 김에 댓글 기능을 위해서 계속 언급되던 Disqus도 적용해보고 Hueman 테마의 기본 설정도 마무리. https://gist.github.com/ihoneymon/652be052a0727ad59601Markdown을 처음 보는 나의 당황스러움을 줄여준 고마운 페이지다. 개인적으로는 카XX께서 강요하다시피 추천한 L모 문법보다 훨씬 나은 것 같다고 생각하지만 숙제를 그걸로만 받겠다고 하시니….추가로 Markdown에 관한 내용은 4번 블로그의 다른 글에도 잘 나와 있다. 테마 수정이 부분부터는 디자인 감각을 영혼까지 끌어모아 적절한 색감을 찾기 위해 노력하였다. 물론 전적으로 내 취향인 테마로 꾸미긴 했지만 그래도 이걸 수정할 누군가가 색 테마 정도는 유지해줬으면 하는 작은 바람이다. 어떻게 보면 적용 부분에서 일한 양은 많지만 고생은 이 부분에서 더 한 것 같다. Hueman 테마가 잘 짜여진 것처럼 보이지만 _variables.styl에 정의된 색상이 있는데도 굳이 다시 HEX형태로 표현한 곳이 많아 모두 잡아내는 데에 난항을 겪었다. 특히 responsive를 위해 구성된 부분에서는 sidebar의 배경색이 사이즈별로 다 나뉘어 있어서 아직도 잡아내지 못한 사이즈가 있을지도 모른다.(ㅠㅜ) 어쨌든 이로써 2018년 5월 5일자로 사이트 구성을 완료하였다. 16-077 이원준(Won-Joon Lee | sni/J)– Designer of EOS 16 wjl0316@naver.com, sniperj_got_ya_back, WonJoonLee0316, sni-J","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-077 Won-Joon Lee","slug":"KSA-16/16-077-Won-Joon-Lee","permalink":"http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"}],"tags":[{"name":"DevLog","slug":"DevLog","permalink":"http://eosofksa.github.io/tags/DevLog/"}]},{"title":"GitHub + Hexo 개발일지 上","slug":"Github-Hexo-Devlog-0","date":"2018-05-03T15:00:00.000Z","updated":"2018-05-07T19:45:30.058Z","comments":true,"path":"2018/05/04/Github-Hexo-Devlog-0/","link":"","permalink":"http://eosofksa.github.io/2018/05/04/Github-Hexo-Devlog-0/","excerpt":"GitHub + Hexo 개발일지 上 - 시작","text":"GitHub + Hexo 개발일지 上 - 시작 시작시작은 대입에 치여 시간을 내지 못하는 3학년들의 부스 활동을 위한 웹 매거진 제작이었다.전시부인 우리 클럽의 특성상 SAF 때는 하는 것이 없기에 이번에는 SAF까지 해보자는 목표로각자 컴퓨터와 관련된 관심분야에 관한 글을 써서 업로드하는 방향으로 진행하고자 하였다. 이 글들을 모아둘 웹 매거진을 제작할 플랫폼으로는 페이스북 페이지 워드프레스 티스토리 가 제시되었지만, 페이스북 페이지의 경우 홍보전 때 물밑이랑 이것저것 복잡하기도 하고,워드프레스보다는 티스토리가 익숙해서 티스토리로 시작했다.티스토리는 애초에 블로그 형식이기에 글의 작성과 편집이 기본적으로 제공되어 간편하고,HTML과 CSS의 수정이 가능하다는 점으로 가볍게 하기에는 비교적 편리하였다. 그.러.나.HTML과 CSS’만’ 수정이 가능하기 때문에 티스토리에서 제공되는 테마 이외에는 적용하기가어렵다는 단점이 있었고, 뭐 때마침 굳이 EOS 이름으로 GitHub 계정을 만들었다고 하기에GitHub 페이지로 제작을 해보고자 하였다. 사실 처음엔 괜찮은 테마가 많아서 Jekyll을 하려고 했다. 근데 Ruby 기반이라 겁먹고 포기…적절한 대안을 찾으려던 중 Hexo가 js 기반이라는 얘기를 보고 이거다 싶어서 시작했다. 16-077 이원준(Won-Joon Lee | sni/J)– Designer of EOS 16 wjl0316@naver.com, sniperj_got_ya_back, WonJoonLee0316, sni-J","categories":[{"name":"KSA 16","slug":"KSA-16","permalink":"http://eosofksa.github.io/categories/KSA-16/"},{"name":"16-077 Won-Joon Lee","slug":"KSA-16/16-077-Won-Joon-Lee","permalink":"http://eosofksa.github.io/categories/KSA-16/16-077-Won-Joon-Lee/"}],"tags":[{"name":"DevLog","slug":"DevLog","permalink":"http://eosofksa.github.io/tags/DevLog/"}]}]}